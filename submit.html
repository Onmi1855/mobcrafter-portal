<!-- === submit.txt (UPDATED FULL) === -->
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MobCrafter - Unit Submit</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, sans-serif; margin: 24px; background:#f6f8fb; color:#0f172a; }
    .card { max-width: 980px; background:#fff; border: 1px solid #e5e7eb; border-radius: 14px; padding: 18px; box-shadow: 0 10px 25px rgba(15,23,42,.08); margin: 0 auto; }
    h1 { margin: 0 0 8px; }
    .muted { color:#64748b; font-size: 13px; }
    .row { display:flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 0 0 auto; }
    select, button, input, textarea { padding: 10px; border-radius: 10px; border: 1px solid #cbd5e1; background:#fff; }
    textarea { width: 100%; min-height: 220px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    button { cursor: pointer; }
    button.primary { background:#2563eb; color:#fff; border: 0; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    pre { background:#f6f6f6; padding: 12px; border-radius: 10px; white-space: pre-wrap; word-break: break-word; }

    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 900px) { .grid2 { grid-template-columns: 1fr; } }

    .thumbcard { border:1px solid #e5e7eb; border-radius: 12px; padding: 12px; background:#fff; }
    .thumbhead { display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:8px; }
    .thumbhead .mini { font-size:12px; color:#64748b; }
    canvas#preview3d { width: 100%; height: auto; border-radius: 12px; border: 1px solid #e5e7eb; background: linear-gradient(180deg, #e6f0ff, #f5f9ff); image-rendering: pixelated; }
  </style>
</head>
<body>
  <div class="card">
    <h1>ユニット投稿</h1>
    <div class="muted">JSON を貼り付けて投稿します。サムネ3Dプレビューは簡易描画（見切れないよう自動フィット）。</div>

    <div style="height:12px"></div>

    <div class="grid2">
      <div>
        <div class="row">
          <label>タイトル <input id="title" type="text" placeholder="例: Sephiroth Statue" style="min-width: 320px;" /></label>
          <label>タグ <input id="tags" type="text" placeholder="例: ff7 boss sword" style="min-width: 320px;" /></label>
        </div>
        <div style="height:10px"></div>
        <label class="muted">説明（最大2000）</label>
        <input id="desc" type="text" placeholder="説明…" style="width:100%;" />

        <div style="height:12px"></div>

        <label class="muted">JSON（貼り付け）</label>
        <textarea id="json" placeholder='{"blocks":[{"dx":0,"dy":1,"dz":0,"blockId":"minecraft:stone"}]}'></textarea>

        <div style="height:12px"></div>

        <div class="row">
          <label>Yaw補正
            <select id="yaw">
              <option value="270" selected>Yaw補正 +270°</option>
              <option value="180">Yaw補正 +180°</option>
              <option value="90">Yaw補正 +90°</option>
              <option value="0">Yaw補正 なし</option>
            </select>
          </label>
          <button id="btnPreview">プレビュー更新</button>
          <button id="btnSubmit" class="primary">投稿</button>
        </div>

        <div style="height:10px"></div>
        <div class="muted">※ 投稿にはログインが必要です（Cloudflare Access）。</div>

        <div style="height:12px"></div>
        <div class="muted">ログ</div>
        <pre id="log">ready</pre>
      </div>

      <div class="thumbcard">
        <div class="thumbhead">
          <div>
            <div style="font-weight:800;">3Dプレビュー</div>
            <div class="mini">見切れないように自動フィット</div>
          </div>
          <div class="mini" id="meta">-</div>
        </div>
        <canvas id="preview3d" width="520" height="420"></canvas>
      </div>
    </div>
  </div>

<script>
(() => {
  const API_SUBMIT = "/api/submit"; // 既存Workerに合わせる

  const $title = document.getElementById("title");
  const $tags  = document.getElementById("tags");
  const $desc  = document.getElementById("desc");
  const $json  = document.getElementById("json");
  const $yaw   = document.getElementById("yaw");

  const $btnPreview = document.getElementById("btnPreview");
  const $btnSubmit  = document.getElementById("btnSubmit");

  const $log  = document.getElementById("log");
  const $meta = document.getElementById("meta");

  const $canvas = document.getElementById("preview3d");

  function log(v){
    $log.textContent = typeof v === "string" ? v : JSON.stringify(v, null, 2);
  }

  function parseJsonSafe(txt){
    try { return JSON.parse(txt); } catch { return null; }
  }

  function normalizeBlocks(obj){
    if(!obj || typeof obj !== "object") return [];
    const blocks = obj.blocks;
    if(!Array.isArray(blocks)) return [];
    return blocks.map(b => ({
      dx: Number(b.dx||0),
      dy: Number(b.dy||0),
      dz: Number(b.dz||0),
      blockId: String(b.blockId||"")
    }));
  }

  // --- iso cube renderer (existing) ---
  function drawIsoCube(ctx, x,y,z, s, blockId){
    // iso projection
    const sx = (x - z) * s;
    const sy = (x + z) * s * 0.5 - y * s;

    // pseudo color by blockId
    let hash=0;
    for(let i=0;i<blockId.length;i++) hash = ((hash<<5)-hash + blockId.charCodeAt(i))|0;
    const rr = 120 + (hash & 63);
    const gg = 120 + ((hash>>6) & 63);
    const bb = 120 + ((hash>>12) & 63);

    // top
    ctx.fillStyle = `rgba(${rr%256},${gg%256},${bb%256},0.95)`;
    ctx.beginPath();
    ctx.moveTo(sx, sy - s);
    ctx.lineTo(sx + s, sy - s*0.5);
    ctx.lineTo(sx, sy);
    ctx.lineTo(sx - s, sy - s*0.5);
    ctx.closePath();
    ctx.fill();

    // left
    ctx.fillStyle = `rgba(${(rr-20)%256},${(gg-20)%256},${(bb-20)%256},0.92)`;
    ctx.beginPath();
    ctx.moveTo(sx - s, sy - s*0.5);
    ctx.lineTo(sx, sy);
    ctx.lineTo(sx, sy + s);
    ctx.lineTo(sx - s, sy + s*0.5);
    ctx.closePath();
    ctx.fill();

    // right
    ctx.fillStyle = `rgba(${(rr-35)%256},${(gg-35)%256},${(bb-35)%256},0.92)`;
    ctx.beginPath();
    ctx.moveTo(sx + s, sy - s*0.5);
    ctx.lineTo(sx, sy);
    ctx.lineTo(sx, sy + s);
    ctx.lineTo(sx + s, sy + s*0.5);
    ctx.closePath();
    ctx.fill();

    // outline
    ctx.strokeStyle = "rgba(15,23,42,.10)";
    ctx.stroke();
  }

  // ★ 見切れ対策：bounds を計算して scale/translate を自動決定
  function renderThumbToCanvas(canvas, blocks, yawDeg, extraOffsetQuarter){
    const ctx = canvas.getContext("2d");
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    if(!Array.isArray(blocks) || blocks.length === 0){
      ctx.fillStyle = "rgba(15,23,42,.45)";
      ctx.font = "14px sans-serif";
      ctx.fillText("No blocks", 10, 24);
      return;
    }

    // --- rotate blocks ---
    const yaw = ((yawDeg||0) * Math.PI/180);
    const rot = blocks.map(b => {
      const x0 = Number(b.dx||0), y = Number(b.dy||0), z0 = Number(b.dz||0);
      const x = x0*Math.cos(yaw) - z0*Math.sin(yaw);
      const z = x0*Math.sin(yaw) + z0*Math.cos(yaw);
      return { x, y, z, blockId: String(b.blockId||"") };
    });

    // --- projected bounds with s=1 ---
    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
    for(const p of rot){
      const sx = (p.x - p.z);
      const sy = (p.x + p.z)*0.5 - p.y;

      const ex = 1.1;
      const eyTop = 0.7;
      const eyBot = 1.9;

      minX = Math.min(minX, sx - ex);
      maxX = Math.max(maxX, sx + ex);
      minY = Math.min(minY, sy - eyTop);
      maxY = Math.max(maxY, sy + eyBot);
    }

    const spanX = Math.max(1e-6, (maxX - minX));
    const spanY = Math.max(1e-6, (maxY - minY));

    const pad = 12;
    const s = Math.max(1.0, Math.min((w - pad*2)/spanX, (h - pad*2)/spanY));

    const cx = (minX + maxX)/2;
    const cy = (minY + maxY)/2;

    let ox = w/2 - cx * s;
    let oy = h/2 - cy * s;

    // subtle grounding
    oy += Math.min(18, h*0.06);

    ctx.save();
    ctx.translate(ox, oy);

    // depth sort back -> front
    rot.sort((a,b) => (a.x + a.z + a.y*0.2) - (b.x + b.z + b.y*0.2));

    for(const p of rot){
      const x = p.x + (extraOffsetQuarter||0)*0.25;
      const z = p.z - (extraOffsetQuarter||0)*0.25;
      drawIsoCube(ctx, x, p.y, z, s, p.blockId);
    }

    ctx.restore();
  }

  function updatePreview(){
    const obj = parseJsonSafe($json.value);
    const blocks = normalizeBlocks(obj);
    const yaw = Number($yaw.value || 270);
    renderThumbToCanvas($canvas, blocks, yaw, 0);
    $meta.textContent = blocks.length ? `${blocks.length} blocks` : "-";
  }

  async function submit(){
    const obj = parseJsonSafe($json.value);
    if(!obj){ alert("JSONが壊れています"); return; }

    const payload = {
      title: $title.value || "",
      description: $desc.value || "",
      tags: $tags.value || "",
      json: obj
    };

    $btnSubmit.disabled = true;
    log("submitting...");
    try{
      const r = await fetch(API_SUBMIT, {
        method: "POST",
        credentials: "include",
        headers: { "Content-Type":"application/json", "Accept":"application/json" },
        body: JSON.stringify(payload)
      });
      const text = await r.text();
      let data = null;
      try { data = JSON.parse(text); } catch { data = { raw:text }; }

      if(!r.ok){
        log({ ok:false, http:r.status, data });
        alert("投稿に失敗しました（ログ参照）");
        return;
      }

      log({ ok:true, data });
      // 送信後は自分の投稿表示で戻る
      location.href = "/?mine=1";
    }catch(e){
      log({ ok:false, error:String(e) });
      alert("通信に失敗しました（ログ参照）");
    }finally{
      $btnSubmit.disabled = false;
    }
  }

  $btnPreview.addEventListener("click", updatePreview);
  $btnSubmit.addEventListener("click", submit);
  $json.addEventListener("input", () => {
    // heavyになり過ぎないよう軽めに
    try { updatePreview(); } catch {}
  });

  updatePreview();
})();
</script>
</body>
</html>
