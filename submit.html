<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MobCrafter - Unit Submit</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, sans-serif; margin: 24px; background:#f6f8fb; color:#0f172a; }
    .card { max-width: 880px; background:#fff; border: 1px solid #e5e7eb; border-radius: 14px; padding: 18px; box-shadow: 0 10px 25px rgba(15,23,42,.08); }
    h1 { margin: 0 0 6px; }
    .hint { color:#555; font-size: 13px; margin: 6px 0 10px; }
    label { display:block; margin-top: 12px; font-weight: 600; }
    input[type="text"], textarea, select { width: 100%; padding: 10px; border: 1px solid #cbd5f5; border-radius: 10px; background:#fff; }
    textarea { min-height: 96px; }
    .row { display:flex; gap: 12px; }
    .row > div { flex: 1; }
    .actions { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    button { margin-top: 14px; padding: 10px 14px; border: 0; border-radius: 12px; cursor:pointer; }
    button.primary { background:#111; color:#fff; }
    button.secondary { background:#e5e7eb; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    pre { white-space: pre-wrap; word-break: break-word; background:#f6f6f6; padding: 12px; border-radius: 12px; }
    canvas { margin-top: 10px; background:#fff; border:1px solid #e5e7eb; border-radius:12px; max-width:100%; height:auto; }
    .mini { color:#666; font-size: 12px; margin-top: 6px; }
    .divider { height:1px; background:#e5e7eb; margin:14px 0; }
    .toplinks{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
    .toplinks a{ color:#2563eb; text-decoration:none; border:1px solid rgba(37,99,235,.25); padding:6px 10px; border-radius:999px; background:#fff; }
    .pill{ display:inline-flex; align-items:center; gap:8px; font-size:12px; color:#64748b; }
    .pill code{ background:rgba(148,163,184,.15); border:1px solid rgba(148,163,184,.25); padding:2px 6px; border-radius:999px; color:#0f172a; }
  </style>
</head>
<body>

<div class="card">
  <div class="toplinks">
    <a href="/">← ホームに戻る</a>
    <span class="pill">Login: <code id="authState">checking...</code> <span id="authEmailWrap" style="display:none;">Email: <code id="authEmail"></code></span></span>
  </div>

  <h1>ユニット投稿</h1>
  <div class="hint">
    Cloudflare Access ログイン後に投稿できます。JSONファイルを選択すると、構造検証と簡易3Dプレビューが表示されます。
  </div>

  <label>JSONファイル</label>
  <input id="file" type="file" accept=".json,application/json" />

  <div class="row">
    <div>
      <label>タイトル</label>
      <input id="title" type="text" placeholder="例: Sephiroth Unit v1" />
    </div>
    <div>
      <label>mod_version（任意）</label>
      <input id="modVersion" type="text" placeholder="1.0.0" />
    </div>
  </div>

  <label>説明</label>
  <textarea id="description" placeholder="説明（任意）"></textarea>

  <label>タグ（カンマ区切り）</label>
  <input id="tags" type="text" placeholder="boss, ff7, sword" />

  <label>正面補正（0/90/180/270）※任意</label>
  <select id="yawOffset">
    <option value="0" selected>0°（補正なし）</option>
    <option value="1">+90°</option>
    <option value="2">+180°</option>
    <option value="3">+270°</option>
  </select>
  <div class="mini">
    frontYaw が無い/作品ごとに正面の流派が違う場合、ここで合わせてください（プレビューと投稿メタに保存）。
  </div>

  <div class="actions">
    <button id="btn" class="primary" disabled>送信</button>
    <a id="loginLink" href="/api/login?next=/submit.html" style="display:none; padding:10px 14px; border-radius:12px; background:#2563eb; color:#fff; text-decoration:none;">ログインして投稿</a>
    <span id="needLogin" class="mini">※ 送信はログイン必須</span>
  </div>

  <div class="divider"></div>

  <label>プレビュー（情報）</label>
  <pre id="preview">{}</pre>

  <label>3Dイメージ（簡易）</label>
  <canvas id="canvas" width="520" height="420"></canvas>
  <div class="hint">
    ※ 形状確認用の簡易表示です（色・質感は実物と異なります）
  </div>

  <label>結果</label>
  <pre id="result">未送信</pre>
</div>

<script>
(() => {
  // ===== API =====
  const API_WHOAMI = "/api/whoami";
  const API_LOGIN  = (next) => `/api/login?next=${encodeURIComponent(next)}`;
  const API_SUBMIT = "/api/submit";

  // ===== Elements =====
  const $authState = document.getElementById("authState");
  const $authEmailWrap = document.getElementById("authEmailWrap");
  const $authEmail = document.getElementById("authEmail");
  const $loginLink = document.getElementById("loginLink");
  const $needLogin = document.getElementById("needLogin");

  const $title = document.getElementById("title");
  const $description = document.getElementById("description");
  const $tags = document.getElementById("tags");
  const $modVersion = document.getElementById("modVersion");
  const $file = document.getElementById("file");
  const $yawOffset = document.getElementById("yawOffset");
  const $btn = document.getElementById("btn");
  const $result = document.getElementById("result");

  const $preview = document.getElementById("preview");
  const $canvas = document.getElementById("canvas");
  const ctx = $canvas.getContext("2d");

  let meEmail = null;
  let meUserId = null;
  let meIsAdmin = false;

  let unitJson = null; // parsed JSON object

  function normEmail(v){
    const s = String(v || "").trim().toLowerCase();
    return (s && s.includes("@")) ? s : "";
  }

  // ===== Auth =====
  async function loadWhoami(){
    try{
      $authState.textContent = "checking...";
      $authEmailWrap.style.display = "none";
      $needLogin.style.display = "none";

      const r = await fetch(API_WHOAMI, { cache: "no-store", credentials: "include" });
      const text = await r.text();
      let data = null;
      try { data = JSON.parse(text); } catch { data = null; }

      if(!r.ok || !data){
        setLoggedOut("unknown");
        return;
      }

      const email = normEmail(data.email);
      meEmail = email || null;
      meUserId = String(data.user_id || "").trim() || null;
      meIsAdmin = Boolean(data.is_admin);

      if(!email){
        setLoggedOut("logged out");
        return;
      }

      $authState.textContent = "logged in";
      $authEmailWrap.style.display = "inline";
      $authEmail.textContent = email;

      $loginLink.textContent = "ログアウト";
      $loginLink.href = "/cdn-cgi/access/logout?returnTo=" + encodeURIComponent(location.origin + "/submit.html");
      $btn.disabled = false;
    }catch{
      setLoggedOut("unknown");
    }
  }

  function setLoggedOut(stateText){
    meEmail = null;
    meUserId = null;
    meIsAdmin = false;

    $authState.textContent = stateText || "logged out";
    $authEmailWrap.style.display = "none";
    $needLogin.style.display = "block";

    $loginLink.textContent = "ログイン";
    $loginLink.href = API_LOGIN("/submit.html");

    $btn.disabled = true;
  }

  // ===== Util =====
  function showResult(text, isOk){
    $result.style.display = "block";
    $result.style.borderColor = isOk ? "#bbf7d0" : "#fecdd3";
    $result.style.background = isOk ? "#f0fdf4" : "#fff1f2";
    $result.textContent = text;
  }

  function safeJsonParse(s){
    try { return { ok:true, value: JSON.parse(s) }; }
    catch(e){ return { ok:false, error: e }; }
  }

  // ===== Canvas resize / redraw =====
  function resizeCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(10, $preview.clientWidth);
    const h = Math.max(10, $preview.clientHeight);

    const cw = Math.floor(w * dpr);
    const ch = Math.floor(h * dpr);

    if ($canvas.width !== cw || $canvas.height !== ch){
      $canvas.width = cw;
      $canvas.height = ch;
    }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }

  function clearCanvas(){
    resizeCanvas();
    const w = $preview.clientWidth;
    const h = $preview.clientHeight;
    ctx.clearRect(0,0,w,h);

    // subtle background
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, "#eef5ff");
    g.addColorStop(1, "#ffffff");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // frame
    ctx.strokeStyle = "rgba(15,23,42,.08)";
    ctx.strokeRect(0.5,0.5,w-1,h-1);
  }

  // ===== Color =====
  function hash32(str){
    let h = 2166136261;
    for(let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function hslToRgb(h, s, l){
    // h:0..360, s/l:0..1
    h = ((h%360)+360)%360;
    const c = (1 - Math.abs(2*l - 1)) * s;
    const x = c * (1 - Math.abs(((h/60) % 2) - 1));
    const m = l - c/2;
    let r=0,g=0,b=0;
    if(h < 60){ r=c; g=x; b=0; }
    else if(h < 120){ r=x; g=c; b=0; }
    else if(h < 180){ r=0; g=c; b=x; }
    else if(h < 240){ r=0; g=x; b=c; }
    else if(h < 300){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    return [
      Math.round((r+m)*255),
      Math.round((g+m)*255),
      Math.round((b+m)*255),
    ];
  }

  function shade(rgb, f){
    return rgb.map((v,i)=> i<3 ? Math.max(0, Math.min(255, Math.round(v*f))) : v);
  }

  function rgbStr(rgb){
    return `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
  }

  function colorForBlockId(blockId){
    const h = hash32(blockId || "block");
    const hue = (h % 360);
    const sat = 0.42 + ((h >> 9) % 20) / 100;  // 0.42..0.61
    const lit = 0.52 + ((h >> 17) % 12) / 100; // 0.52..0.63
    return hslToRgb(hue, sat, lit);
  }

  // ===== Iso render (cubes) =====
  function drawIso(blocks, yawDeg){
    clearCanvas();

    if(!Array.isArray(blocks) || blocks.length === 0){
      ctx.fillStyle = "rgba(15,23,42,.35)";
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillText("No blocks", 14, 22);
      return;
    }

    const w = $preview.clientWidth;
    const h = $preview.clientHeight;

    const yaw = (Number(yawDeg||0) * Math.PI) / 180;

    // Prepare rotated coords and projected anchor (iso)
    const pts = blocks.map(b => {
      const x = Number(b.dx||0), y = Number(b.dy||0), z = Number(b.dz||0);
      const rx =  x*Math.cos(yaw) - z*Math.sin(yaw);
      const rz =  x*Math.sin(yaw) + z*Math.cos(yaw);

      // iso projection in "tile units"
      const px = (rx - rz);
      const py = (rx + rz) * 0.5 - y;

      return {
        x, y, z, rx, rz,
        px, py,
        bid: String(b.blockId || "block")
      };
    });

    // Compute bounds using cube extents (each cube occupies 1 unit)
    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
    for(const p of pts){
      // cube corners spread in projection: roughly +/-1 in x and +/-1 in y for our chosen basis
      // We’ll take generous bounds by sampling 4 top corners projection offsets.
      // Offsets are in projected px/py units.
      const xs = [p.px, p.px+1, p.px-1];
      const ys = [p.py, p.py+1, p.py-1];
      for(const xx of xs){ minX=Math.min(minX,xx); maxX=Math.max(maxX,xx); }
      for(const yy of ys){ minY=Math.min(minY,yy); maxY=Math.max(maxY,yy); }
    }

    const pad = 20;
    const spanX = Math.max(1e-6, maxX - minX);
    const spanY = Math.max(1e-6, maxY - minY);

    // Tile size in pixels (auto-fit)
    const tile = Math.max(6, Math.min(
      (w - pad*2) / (spanX * 2.0),   // px is wider
      (h - pad*2) / (spanY * 2.8)    // py includes vertical stack
    ));

    // Cube dimensions in pixels
    const hw = tile;       // half width
    const hh = tile * 0.5; // half height
    const vh = tile;       // vertical height per block

    // Centering
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;

    const ox = w/2 - (cx * hw);
    const oy = h/2 - (cy * hh);

    // Painter's sort: back to front (rz + rx + y) with tie on y
    pts.sort((a,b)=>{
      const da = (a.rx + a.rz) + a.y*0.85;
      const db = (b.rx + b.rz) + b.y*0.85;
      if (da !== db) return da - db;
      return a.y - b.y;
    });

    ctx.lineWidth = 1;

    for(const p of pts){
      const base = colorForBlockId(p.bid);
      const topC = shade(base, 1.06);
      const leftC = shade(base, 0.92);
      const rightC = shade(base, 0.78);

      const x = ox + p.px * hw;
      const y = oy + p.py * hh;

      // Top face (diamond)
      ctx.beginPath();
      ctx.moveTo(x,     y - vh);
      ctx.lineTo(x+hw,  y - vh + hh);
      ctx.lineTo(x,     y - vh + hh*2);
      ctx.lineTo(x-hw,  y - vh + hh);
      ctx.closePath();
      ctx.fillStyle = rgbStr(topC);
      ctx.fill();
      ctx.strokeStyle = "rgba(15,23,42,.10)";
      ctx.stroke();

      // Left face
      ctx.beginPath();
      ctx.moveTo(x-hw,  y - vh + hh);
      ctx.lineTo(x,     y - vh + hh*2);
      ctx.lineTo(x,     y + hh*2);
      ctx.lineTo(x-hw,  y + hh);
      ctx.closePath();
      ctx.fillStyle = rgbStr(leftC);
      ctx.fill();
      ctx.strokeStyle = "rgba(15,23,42,.10)";
      ctx.stroke();

      // Right face
      ctx.beginPath();
      ctx.moveTo(x+hw,  y - vh + hh);
      ctx.lineTo(x,     y - vh + hh*2);
      ctx.lineTo(x,     y + hh*2);
      ctx.lineTo(x+hw,  y + hh);
      ctx.closePath();
      ctx.fillStyle = rgbStr(rightC);
      ctx.fill();
      ctx.strokeStyle = "rgba(15,23,42,.10)";
      ctx.stroke();
    }
  }

  function redraw(){
    if(!unitJson || !Array.isArray(unitJson.blocks)){
      clearCanvas();
      ctx.fillStyle = "rgba(15,23,42,.35)";
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillText("JSONを選択するとプレビューします", 14, 22);
      return;
    }
    drawIso(unitJson.blocks, Number($yawOffset.value||270));
  }

  // ===== File -> JSON =====
  async function readFileAsText(file){
    return await new Promise((resolve, reject)=>{
      const fr = new FileReader();
      fr.onload = () => resolve(String(fr.result || ""));
      fr.onerror = () => reject(fr.error || new Error("read_failed"));
      fr.readAsText(file);
    });
  }

  async function onFileChange(){
    unitJson = null;
    redraw();

    const f = $file.files && $file.files[0];
    if(!f) return;

    try{
      const text = await readFileAsText(f);
      const p = safeJsonParse(text);
      if(!p.ok){
        showResult("JSONが壊れています。ファイル内容を確認してください。\n" + String(p.error?.message || p.error), false);
        return;
      }
      if(!p.value || typeof p.value !== "object"){
        showResult("JSONの形式が不正です。", false);
        return;
      }
      if(!Array.isArray(p.value.blocks) || p.value.blocks.length === 0){
        showResult("blocks が空です（MobCrafter Unit JSON では blocks が必須です）。", false);
        return;
      }
      unitJson = p.value;
      showResult("JSONを読み込みました。プレビューを更新しました。", true);
      redraw();
    }catch(e){
      showResult("ファイル読み込みに失敗しました。\n" + String(e?.message || e), false);
    }
  }

  // ===== Submit =====
  async function submit(){
    if(!meEmail){
      showResult("ログインが必要です。", false);
      return;
    }
    if(!unitJson){
      showResult("JSONファイルを選択してください。", false);
      return;
    }

    const body = {
      title: String($title.value || unitJson.title || "Untitled").slice(0,80),
      description: String($description.value || "").slice(0,2000),
      tags: String($tags.value || "").slice(0,400),
      mod_version: String($modVersion.value || "").slice(0,40),
      json: unitJson
    };

    $btn.disabled = true;
    showResult("送信中...", true);

    try{
      const r = await fetch(API_SUBMIT, {
        method: "POST",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });
      const text = await r.text();
      let data = null;
      try { data = JSON.parse(text); } catch { data = { raw: text }; }

      if(!r.ok){
        throw new Error(`HTTP ${r.status}\n${JSON.stringify(data, null, 2)}`);
      }

      showResult("送信しました（pending）。\n" + JSON.stringify(data, null, 2) + "\n\n一覧へ戻ります…", true);

      // index 側で mine=1 なら自分の投稿のみON
      setTimeout(() => {
        location.href = "/?mine=1";
      }, 800);
    }catch(e){
      showResult("送信に失敗しました。\n" + String(e?.message || e), false);
    }finally{
      $btn.disabled = false;
    }
  }

  // ===== events =====
  $file.addEventListener("change", onFileChange);
  $yawOffset.addEventListener("change", redraw);
  $btn.addEventListener("click", submit);

  // keep preview sized and re-render
  const ro = new ResizeObserver(() => redraw());
  ro.observe($preview);
  window.addEventListener("resize", () => redraw());

  // init
  clearCanvas();
  ctx.fillStyle = "rgba(15,23,42,.35)";
  ctx.font = "14px system-ui, sans-serif";
  ctx.fillText("JSONを選択するとプレビューします", 14, 22);

  (async () => {
    await loadWhoami();
    redraw();
  })();
})();
</script>

</body>
</html>
