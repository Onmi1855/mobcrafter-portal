<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MobCrafter - Unit Submit</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, sans-serif; margin: 24px; background:#f6f8fb; color:#0f172a; }
    .card { max-width: 880px; background:#fff; border: 1px solid #e5e7eb; border-radius: 14px; padding: 18px; box-shadow: 0 10px 25px rgba(15,23,42,.08); }
    h1 { margin: 0 0 6px; }
    .hint { color:#555; font-size: 13px; margin: 6px 0 10px; }
    label { display:block; margin-top: 12px; font-weight: 600; }
    input[type="text"], textarea, select { width: 100%; padding: 10px; border: 1px solid #cbd5f5; border-radius: 10px; background:#fff; }
    textarea { min-height: 96px; }
    .row { display:flex; gap: 12px; }
    .row > div { flex: 1; }
    .actions { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    button { margin-top: 14px; padding: 10px 14px; border: 0; border-radius: 12px; cursor:pointer; }
    button.primary { background:#111; color:#fff; }
    button.secondary { background:#e5e7eb; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    pre { white-space: pre-wrap; word-break: break-word; background:#f6f6f6; padding: 12px; border-radius: 12px; }
    canvas { margin-top: 10px; background:#fff; border:1px solid #e5e7eb; border-radius:12px; max-width:100%; height:auto; }
    .mini { color:#666; font-size: 12px; margin-top: 6px; }
    .divider { height:1px; background:#e5e7eb; margin:14px 0; }
    .toplinks{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
    .toplinks a{ color:#2563eb; text-decoration:none; border:1px solid rgba(37,99,235,.25); padding:6px 10px; border-radius:999px; background:#fff; }
    .pill{ display:inline-flex; align-items:center; gap:8px; font-size:12px; color:#64748b; }
    .pill code{ background:rgba(148,163,184,.15); border:1px solid rgba(148,163,184,.25); padding:2px 6px; border-radius:999px; color:#0f172a; }
    .canvaswrap{ width:100%; max-width:920px; margin:10px 0 0; }
    .canvaswrap canvas{ width:100%; height:auto; display:block; border-radius:12px; }
    .oknote{ margin-top:10px; padding:10px 12px; border-radius:12px; background:#ecfeff; border:1px solid #a5f3fc; color:#0f172a; display:none; }
    .errnote{ margin-top:10px; padding:10px 12px; border-radius:12px; background:#fef2f2; border:1px solid #fecaca; color:#991b1b; display:none; }
    .ver { font-size:12px; color:#64748b; margin-left:auto; }
  </style>
</head>
<body>
<div class="card">
  <div class="toplinks">
    <a href="/">← ホームに戻る</a>
    <span class="pill">Login: <code id="loginState">checking...</code></span>
    <span class="pill">Email: <code id="meEmail">-</code></span>
    <span class="ver">submit.screens.v3</span>
  </div>

  <h1>ユニット投稿</h1>
  <div class="hint">Cloudflare Access のログインに対応できます。JSONファイルを選択すると、構造体の簡易3Dプレビューが表示されます。</div>

  <label>JSONファイル</label>
  <input id="file" type="file" accept=".json,application/json" />

  <div class="row">
    <div>
      <label>タイトル</label>
      <input id="title" type="text" placeholder="例: Sephiroth Unit v1" />
    </div>
    <div>
      <label>mod_version（任意）</label>
      <input id="modver" type="text" placeholder="1.0.0" />
    </div>
  </div>

  <label>説明</label>
  <textarea id="desc" placeholder="説明（任意）"></textarea>

  <label>タグ（カンマ区切り）</label>
  <input id="tags" type="text" placeholder="boss, ff7, sword" />

  <label>正面補正（0/90/180/270）※任意</label>
  <select id="yaw">
    <option value="">0°（補正なし）</option>
    <option value="90">+90°</option>
    <option value="180">+180°</option>
    <option value="270">+270°</option>
  </select>
  <div class="mini">frontYaw が無い/怪しい場合に正面補正が適用されます（プレビューと投稿メタに保存）。</div>

  <div class="actions">
    <button id="btnSubmit" class="primary" disabled>送信</button>
    <button id="btnLogin" class="secondary" style="display:none;">ログインへ</button>
  </div>

  <div class="divider"></div>

  <h3>プレビュー（情報）</h3>
  <pre id="preview">{}</pre>

  <h3>3Dイメージ（簡易）</h3>
  <div class="canvaswrap">
    <canvas id="cv" width="920" height="520"></canvas>
  </div>
  <div class="mini">※ 形状確認用の簡易表示です（色・描画ロジックは変更しません）</div>

  <div class="divider"></div>

  <h3>スクリーンショット（任意）</h3>
  <div class="actions">
    <input id="shotFile" type="file" accept="image/*" />
    <button id="btnUploadShot" class="secondary" disabled>スクショをアップロード</button>
    <button id="btnUploadShotFromCanvas" class="secondary" disabled>プレビューをスクショしてアップロード</button>
  </div>
  <div class="mini">※ スクショは「投稿が成功して submission_id が確定」してからアップロードできます。</div>

  <div class="divider"></div>

  <h3>結果</h3>
  <pre id="result">未送信</pre>
  <div id="oknote" class="oknote"></div>
  <div id="errnote" class="errnote"></div>
</div>

<script>
(() => {
  const API = ""; // same-origin
  const $ = (id) => document.getElementById(id);

  const els = {
    loginState: $("loginState"),
    meEmail: $("meEmail"),
    file: $("file"),
    title: $("title"),
    modver: $("modver"),
    desc: $("desc"),
    tags: $("tags"),
    yaw: $("yaw"),
    btnSubmit: $("btnSubmit"),
    btnLogin: $("btnLogin"),
    preview: $("preview"),
    result: $("result"),
    oknote: $("oknote"),
    errnote: $("errnote"),
    cv: $("cv"),
    shotFile: $("shotFile"),
    btnUploadShot: $("btnUploadShot"),
    btnUploadShotFromCanvas: $("btnUploadShotFromCanvas"),
  };

  let whoami = { ok:false, email:null, is_admin:false };
  let parsed = null;          // parsed JSON
  let blocks = [];            // blocks array
  let submissionId = null;    // after successful submit
  let currentEditId = null;   // for future edit mode (not enabled here)

  // -------- Robust whoami (never blocks preview) ----------
  async function loadWhoami() {
    try {
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), 6000);
      const res = await fetch(API + "/api/whoami", { credentials:"include", signal: ctrl.signal });
      clearTimeout(t);
      const data = await res.json().catch(() => ({ ok:false }));
      whoami = data && typeof data === "object" ? data : { ok:false };
    } catch (e) {
      whoami = { ok:false, email:null, is_admin:false };
    }

    const logged = !!(whoami && whoami.ok && whoami.email);
    els.loginState.textContent = logged ? "logged in" : "not logged in";
    els.meEmail.textContent = logged ? whoami.email : "-";

    if (!logged) {
      els.btnLogin.style.display = "";
      els.btnLogin.onclick = () => { location.href = "/api/login?next=/submit"; };
    } else {
      els.btnLogin.style.display = "none";
    }

    updateButtons();
  }

  function showOk(msg) {
    els.oknote.style.display = "block";
    els.oknote.textContent = msg;
    els.errnote.style.display = "none";
  }
  function showErr(msg) {
    els.errnote.style.display = "block";
    els.errnote.textContent = msg;
    els.oknote.style.display = "none";
  }

  function updateButtons() {
    const logged = !!(whoami && whoami.ok && whoami.email);
    const hasJson = !!parsed;
    els.btnSubmit.disabled = !(logged && hasJson);

    const canUploadShot = logged && !!submissionId;
    els.btnUploadShot.disabled = !canUploadShot;
    els.btnUploadShotFromCanvas.disabled = !canUploadShot;
  }

  // ----------- Parsing -----------
  async function parseFile(file) {
    if (!file) { parsed=null; blocks=[]; els.preview.textContent="{}"; drawEmpty(); updateButtons(); return; }
    try {
      const text = await file.text();
      const json = JSON.parse(text);
      parsed = json;
      blocks = Array.isArray(json.blocks) ? json.blocks : [];
      els.preview.textContent = JSON.stringify(summarize(json), null, 2);
      render();
      updateButtons();
      showOk("JSONを読み込みました（未送信）。ログイン済みなら送信できます。");
    } catch (e) {
      parsed = null; blocks = [];
      els.preview.textContent = "{}";
      drawEmpty();
      updateButtons();
      showErr("JSONの読み込みに失敗しました: " + (e?.message || String(e)));
    }
  }

  function summarize(json) {
    const b = Array.isArray(json.blocks) ? json.blocks : [];
    let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
    for (const it of b) {
      const x=it?.x, y=it?.y, z=it?.z;
      if (typeof x!=="number"||typeof y!=="number"||typeof z!=="number") continue;
      if (x<minX) minX=x; if (y<minY) minY=y; if (z<minZ) minZ=z;
      if (x>maxX) maxX=x; if (y>maxY) maxY=y; if (z>maxZ) maxZ=z;
    }
    const size = (minX!==Infinity) ? { x:(maxX-minX+1), y:(maxY-minY+1), z:(maxZ-minZ+1) } : null;
    return {
      file: { name: els.file.files?.[0]?.name || null, size: els.file.files?.[0]?.size || null },
      blocks: b.length,
      aabb: size ? { size, min:{x:minX,y:minY,z:minZ}, max:{x:maxX,y:maxY,z:maxZ} } : null,
      frontYaw: json.frontYaw ?? null,
      yaw_offset_quarter: json.yaw_offset_quarter ?? null
    };
  }

  // ----------- Palette & cube shading (kept consistent) ----------
  const PALETTE = {
    // minimal baseline; server side palette is separate; this is preview only.
    "minecraft:black_concrete": "#151515",
    "minecraft:white_concrete": "#e6e6e6",
    "minecraft:light_blue_concrete": "#3aa7ff",
    "minecraft:orange_concrete": "#f28c28",
    "minecraft:yellow_concrete": "#f1d92b",
    "minecraft:blue_concrete": "#1f4bd6",
    "minecraft:gold_block": "#d6b14a",
    "minecraft:stone": "#8a8f99",
    "minecraft:gray_concrete": "#5a5f66",
    "minecraft:light_gray_concrete": "#b7bcc2",
    "minecraft:purple_concrete": "#7b2fbf",
    "minecraft:pink_concrete": "#f08fb2",
    "minecraft:lime_concrete": "#7bdc2c",
    "minecraft:green_concrete": "#3f8f2b",
    "minecraft:air": null
  };

  function hexToRgb(hex) {
    const m = /^#?([0-9a-f]{6})$/i.exec(hex || "");
    if (!m) return null;
    const n = parseInt(m[1], 16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }
  function shade(hex, f) {
    const c = hexToRgb(hex);
    if (!c) return hex;
    const r = Math.max(0, Math.min(255, Math.round(c.r * f)));
    const g = Math.max(0, Math.min(255, Math.round(c.g * f)));
    const b = Math.max(0, Math.min(255, Math.round(c.b * f)));
    return `rgb(${r},${g},${b})`;
  }
  function getColor(blockId) {
    if (!blockId || blockId === "minecraft:air") return null;
    const hex = PALETTE[blockId];
    if (typeof hex === "string") return hex;
    // fallback deterministic grayscale
    let h = 0;
    for (let i=0;i<blockId.length;i++) h = (h*31 + blockId.charCodeAt(i)) >>> 0;
    const v = 60 + (h % 150);
    return `rgb(${v},${v},${v})`;
  }

  // ----------- Isometric projection fit (the fixed part) ----------
  const ctx = els.cv.getContext("2d");
  function drawEmpty() {
    ctx.clearRect(0,0,els.cv.width,els.cv.height);
  }

  function projectIso(x,y,z) {
    // base iso: x to right-down, z to left-down, y up
    return { px: (x - z), py: (x + z) * 0.5 - y };
  }

  function computeIsoBBox(blocks) {
    // include cube extents (each cube is 1x1x1). We approximate by sampling 8 cube corners projected.
    let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
    for (const b of blocks) {
      const x=b?.x, y=b?.y, z=b?.z;
      if (typeof x!=="number"||typeof y!=="number"||typeof z!=="number") continue;
      if (x<minX) minX=x; if (y<minY) minY=y; if (z<minZ) minZ=z;
      if (x>maxX) maxX=x; if (y>maxY) maxY=y; if (z>maxZ) maxZ=z;
    }
    if (minX===Infinity) return null;

    let minPX=Infinity, minPY=Infinity, maxPX=-Infinity, maxPY=-Infinity;

    function addPt(px,py) {
      if (px<minPX) minPX=px;
      if (py<minPY) minPY=py;
      if (px>maxPX) maxPX=px;
      if (py>maxPY) maxPY=py;
    }

    // cover full voxel bounds by scanning each block as cube (tight but safe)
    for (const b of blocks) {
      const x=b.x, y=b.y, z=b.z;
      // 8 corners of cube
      const corners = [
        [x, y, z],
        [x+1, y, z],
        [x, y+1, z],
        [x, y, z+1],
        [x+1, y+1, z],
        [x+1, y, z+1],
        [x, y+1, z+1],
        [x+1, y+1, z+1],
      ];
      for (const [cx,cy,cz] of corners) {
        const p = projectIso(cx,cy,cz);
        addPt(p.px, p.py);
      }
    }

    return { minPX, minPY, maxPX, maxPY };
  }

  function render() {
    drawEmpty();
    if (!blocks || blocks.length===0) return;

    // compute bbox in iso space
    const bbox = computeIsoBBox(blocks);
    if (!bbox) return;

    const W = els.cv.width, H = els.cv.height;
    const margin = 24;

    const bw = bbox.maxPX - bbox.minPX;
    const bh = bbox.maxPY - bbox.minPY;

    // scale so it fits
    const s = Math.min((W - margin*2) / (bw || 1), (H - margin*2) / (bh || 1));

    // center
    const cx = (bbox.minPX + bbox.maxPX) * 0.5;
    const cy = (bbox.minPY + bbox.maxPY) * 0.5;
    const ox = W * 0.5 - cx * s;
    const oy = H * 0.55 - cy * s; // slightly lower feels nicer

    // sort blocks back-to-front
    const sorted = blocks
      .filter(b => b && typeof b.x==="number" && typeof b.y==="number" && typeof b.z==="number")
      .slice()
      .sort((a,b) => (a.x+a.z+a.y*2) - (b.x+b.z+b.y*2));

    // cube draw parameters
    const tile = s * 1.0;      // base unit
    const halfW = tile * 0.5;
    const halfH = tile * 0.25;
    const h = tile * 0.5;

    for (const b of sorted) {
      const col = getColor(b.id || b.block || b.name || b.type || b.blockId || b.block_id);
      if (!col) continue;

      const p = projectIso(b.x, b.y, b.z);
      const x = ox + p.px * s;
      const y = oy + p.py * s;

      // top
      ctx.beginPath();
      ctx.moveTo(x, y - h);
      ctx.lineTo(x + halfW, y - h + halfH);
      ctx.lineTo(x, y - h + halfH*2);
      ctx.lineTo(x - halfW, y - h + halfH);
      ctx.closePath();
      ctx.fillStyle = shade(col, 1.15);
      ctx.fill();

      // left
      ctx.beginPath();
      ctx.moveTo(x - halfW, y - h + halfH);
      ctx.lineTo(x, y - h + halfH*2);
      ctx.lineTo(x, y + halfH*2);
      ctx.lineTo(x - halfW, y + halfH);
      ctx.closePath();
      ctx.fillStyle = shade(col, 0.85);
      ctx.fill();

      // right
      ctx.beginPath();
      ctx.moveTo(x + halfW, y - h + halfH);
      ctx.lineTo(x, y - h + halfH*2);
      ctx.lineTo(x, y + halfH*2);
      ctx.lineTo(x + halfW, y + halfH);
      ctx.closePath();
      ctx.fillStyle = shade(col, 0.95);
      ctx.fill();
    }
  }

  // ----------- Submit -----------
  async function doSubmit() {
    if (!parsed) { showErr("JSONが未読み込みです"); return; }
    if (!(whoami && whoami.ok && whoami.email)) { showErr("ログインが必要です"); return; }

    els.btnSubmit.disabled = true;
    showOk("送信中...");

    try {
      const payload = {
        title: els.title.value.trim() || null,
        description: els.desc.value.trim() || null,
        tags: els.tags.value.trim() || null,
        mod_version: els.modver.value.trim() || null,
        yaw: els.yaw.value ? parseInt(els.yaw.value,10) : 0,
        json: parsed
      };

      const res = await fetch(API + "/api/submit", {
        method: "POST",
        headers: { "content-type":"application/json" },
        credentials: "include",
        body: JSON.stringify(payload)
      });

      const data = await res.json().catch(() => ({}));
      els.result.textContent = JSON.stringify(data, null, 2);

      if (!res.ok || !data.ok) {
        showErr("送信に失敗しました: " + (data.error || res.status));
        els.btnSubmit.disabled = false;
        return;
      }

      submissionId = data.id || data.submission_id || data.submissionId || null;
      updateButtons();
      showOk("送信完了！このページは自動では戻りません。下のボタンからスクショアップロードや詳細ページへ進めます。");

    } catch (e) {
      showErr("送信エラー: " + (e?.message || String(e)));
    } finally {
      updateButtons();
    }
  }

  // ----------- Screenshot upload -----------
  async function uploadShotBlob(blob, filename) {
    if (!submissionId) { showErr("先に投稿を完了してください（submission_id未確定）"); return; }
    if (!(whoami && whoami.ok && whoami.email)) { showErr("ログインが必要です"); return; }

    try {
      const fd = new FormData();
      fd.append("file", blob, filename || "shot.webp");

      const res = await fetch(API + `/api/submissions/${encodeURIComponent(submissionId)}/screens`, {
        method: "POST",
        credentials: "include",
        body: fd
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok || !data.ok) {
        showErr("スクショアップロード失敗: " + (data.error || res.status));
        return;
      }
      showOk("スクショアップロード成功！ unitページの「スクリーンショット」で確認できます。");
      els.result.textContent = JSON.stringify(data, null, 2);
    } catch (e) {
      showErr("スクショアップロードエラー: " + (e?.message || String(e)));
    }
  }

  // ----------- Wire up ----------
  els.file.addEventListener("change", () => parseFile(els.file.files[0]));
  els.btnSubmit.addEventListener("click", doSubmit);

  els.btnUploadShot.addEventListener("click", async () => {
    const f = els.shotFile.files && els.shotFile.files[0];
    if (!f) { showErr("スクショファイルを選んでください"); return; }
    const blob = f.slice(0, f.size, f.type || "image/png");
    await uploadShotBlob(blob, f.name || "shot.png");
  });

  els.btnUploadShotFromCanvas.addEventListener("click", async () => {
    const blob = await new Promise((resolve) => els.cv.toBlob(resolve, "image/webp", 0.92));
    if (!blob) { showErr("canvasからスクショ生成に失敗しました"); return; }
    await uploadShotBlob(blob, "preview.webp");
  });

  // initial
  drawEmpty();
  loadWhoami(); // do not block
})();
</script>

</body>
</html>
