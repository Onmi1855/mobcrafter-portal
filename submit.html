<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MobCrafter - Unit Submit</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, sans-serif; margin: 24px; background:#f6f8fb; color:#0f172a; }
    .card { max-width: 880px; background:#fff; border: 1px solid #e5e7eb; border-radius: 14px; padding: 18px; box-shadow: 0 10px 25px rgba(15,23,42,.08); }
    h1 { margin: 0 0 6px; }
    .muted { color:#64748b; font-size: 13px; }
    label { display:block; margin-top: 14px; font-weight: 600; }
    input[type="text"], textarea, select {
      width:100%; box-sizing:border-box; padding:10px 12px; border:1px solid #e5e7eb; border-radius: 10px; font-size: 14px;
      background:#fff;
    }
    textarea { min-height: 110px; resize: vertical; }
    .row { display:flex; gap:12px; flex-wrap: wrap; }
    .row > div { flex:1 1 240px; }
    .actions { display:flex; gap:10px; align-items:center; flex-wrap: wrap; margin-top: 16px; }
    button.primary {
      background:#2563eb; color:#fff; border:0; border-radius: 12px; padding: 12px 18px; font-weight: 700; cursor:pointer;
      box-shadow: 0 10px 20px rgba(37,99,235,.15);
    }
    button.primary:disabled { opacity:.55; cursor:not-allowed; box-shadow:none; }
    .divider { height:1px; background:#e5e7eb; margin: 16px 0; }
    .hint { font-size: 12px; color:#64748b; line-height: 1.45; margin-top: 6px; }
    .pill { display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius: 999px; background:#eef2ff; color:#3730a3; font-size: 12px; font-weight:700; }
    .warn { display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius: 999px; background:#fff7ed; color:#9a3412; font-size: 12px; font-weight:700; }
    pre { background:#0b1220; color:#e5e7eb; padding: 12px; border-radius: 12px; overflow:auto; }
    .mini { font-size: 13px; color:#334155; }
    .canvaswrap { margin-top: 10px; background:#0b1220; border-radius: 14px; overflow:hidden; border:1px solid #0f172a; }
    canvas { display:block; width:100%; height:auto; image-rendering: pixelated; }
    .topbar { display:flex; justify-content: space-between; align-items:center; gap:12px; flex-wrap:wrap; }
    .auth { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .auth small { color:#64748b; }
  </style>
</head>
<body>
<div class="card">
  <div class="topbar">
    <div>
      <h1>Unit Submit</h1>
      <div class="muted">MobCrafter ユニット JSON を投稿します（ログイン必須）</div>
    </div>
    <div class="auth">
      <span id="authState" class="pill">checking...</span>
      <span id="authEmailWrap" class="mini" style="display:none;">as <b id="authEmail"></b></span>
      <a id="loginBtn" href="/api/login?next=/submit" style="display:none; padding:8px 10px; border-radius:10px; border:1px solid #e5e7eb; text-decoration:none; color:#0f172a; background:#fff;">Login</a>
      <a id="logoutBtn" href="/api/logout?next=/submit" style="display:none; padding:8px 10px; border-radius:10px; border:1px solid #e5e7eb; text-decoration:none; color:#0f172a; background:#fff;">Logout</a>
    </div>
  </div>

  <div class="divider"></div>

  <label>Unit JSON ファイル</label>
  <input id="file" type="file" accept=".json,application/json" />
  <div class="hint">※ 1つの JSON をアップロードしてください（blocks配列が必要）</div>

  <div class="row">
    <div>
      <label>タイトル</label>
      <input id="title" type="text" placeholder="例: Castle Archer Tower" />
    </div>
    <div>
      <label>タグ（カンマ区切り）</label>
      <input id="tags" type="text" placeholder="castle, archer, tower" />
    </div>
  </div>

  <label>説明</label>
  <textarea id="desc" placeholder="使い方や特徴など"></textarea>

  <div class="row">
    <div>
      <label>Minecraft Version</label>
      <input id="mcver" type="text" placeholder="1.20.1" />
    </div>
    <div>
      <label>Mod Version</label>
      <input id="modver" type="text" placeholder="v34" />
    </div>
  </div>

  <label>正面調整（yaw offset）</label>
  <select id="yawOffset">
    <option value="0">+0°</option>
    <option value="1">+90°</option>
    <option value="2">+180°</option>
    <option value="3">+270°</option>
  </select>
  <div class="mini">
    frontYaw が無い/作品ごとに正面の流派が違う場合、ここで合わせてください（プレビューと投稿メタに保存）。
  </div>

  <div class="actions">
    <button id="btn" class="primary" disabled>送信</button>
    <a id="loginLink" href="/api/login?next=/submit" style="display:none; padding:10px 14px; border-radius:12px; background:#2563eb; color:#fff; text-decoration:none;">ログインして投稿</a>
    <span id="needLogin" class="mini">※ 送信はログイン必須</span>
  </div>

  <!-- ✅ 送信成功/失敗はここ（送信ボタン直下） -->
  <div id="submitMsg" class="mini" style="margin-top:8px;"></div>

  <!-- ✅ JSON送信成功後だけ表示：スクショアップロード + サムネ選択 -->
  <div id="afterSuccess" class="mini" style="display:none; margin-top:8px;"></div>

  <div class="divider"></div>

  <label>プレビュー（情報）</label>
  <pre id="preview">{}</pre>

  <label>3Dイメージ（簡易）</label>
  <div class="canvaswrap"><canvas id="canvas" width="900" height="520"></canvas></div>
  <div class="hint">
    ※ 形状確認用の簡易表示です（色・質感は実物と異なります）
  </div>

  <label>結果</label>
  <pre id="result">未送信</pre>
</div>

<script>
(() => {
  const API_WHOAMI = "/api/whoami";

  const authState = document.getElementById("authState");
  const authEmailWrap = document.getElementById("authEmailWrap");
  const authEmail = document.getElementById("authEmail");

  const $file = document.getElementById("file");
  const $title = document.getElementById("title");
  const $tags = document.getElementById("tags");
  const $desc = document.getElementById("desc");
  const $mc = document.getElementById("mcver");
  const $mv = document.getElementById("modver");
  const $btn = document.getElementById("btn");
  const $loginLink = document.getElementById("loginLink");
  const $needLogin = document.getElementById("needLogin");
  const $prev  = document.getElementById("preview");
  const $res   = document.getElementById("result");
  const $submitMsg = document.getElementById("submitMsg");
  const $afterSuccess = document.getElementById("afterSuccess");

  const $yawOffset = document.getElementById("yawOffset");
  const canvas = document.getElementById("canvas");

  let parsedJson = null;
  let jsonDirty = false;
  let lastSubmissionId = "";

  // --- Edit mode (B案) ---
  // URLに ?edit=1&id=... が来た場合に既存投稿の編集として扱う
  const url = new URL(location.href);
  const isEditMode = url.searchParams.get("edit") === "1";
  const editId = url.searchParams.get("id") || "";

  let isLoggedIn = false;
  let loggedInEmail = "";
  let isAdmin = false;

  function setPreview(v) {
    $prev.textContent = typeof v === "string" ? v : JSON.stringify(v, null, 2);
  }
  function setResult(v) {
    $res.textContent = typeof v === "string" ? v : JSON.stringify(v, null, 2);
  }
  function updateButtonState() {
    // ★ログイン必須＋json＋title
    $btn.disabled = !(isLoggedIn && parsedJson && ($title.value || "").trim());
  }

  function validateMobCrafterJson(obj) {
    if (!obj || typeof obj !== "object") return "JSONがオブジェクトではありません";
    if (!Array.isArray(obj.blocks)) return "blocks 配列がありません";
    if (obj.blocks.length === 0) return "blocks が空です";
    if (obj.blocks.length > 20000) return "blocks が多すぎます（上限 20000 を超えています）";
    return "";
  }

  function normEmail(s) {
    return (s || "").toString().trim().toLowerCase();
  }

  async function whoami() {
    try {
      const r = await fetch(API_WHOAMI, { cache:"no-store", credentials:"include" });
      const j = await r.json().catch(()=>null);
      if (!r.ok || !j || j.ok !== true) return { ok:false };
      return j;
    } catch(e) {
      return { ok:false };
    }
  }

  function setAuthUI(state) {
    if (state.ok) {
      isLoggedIn = true;
      loggedInEmail = state.email || "";
      isAdmin = !!state.is_admin;

      authState.textContent = isAdmin ? "admin" : "logged in";
      authState.className = "pill";
      authEmailWrap.style.display = loggedInEmail ? "inline" : "none";
      authEmail.textContent = loggedInEmail || "";
      document.getElementById("loginBtn").style.display = "none";
      document.getElementById("logoutBtn").style.display = "inline-block";
      $loginLink.style.display = "none";
      $needLogin.style.display = "none";
    } else {
      isLoggedIn = false;
      loggedInEmail = "";
      isAdmin = false;

      authState.textContent = "guest";
      authState.className = "warn";
      authEmailWrap.style.display = "none";
      document.getElementById("loginBtn").style.display = "inline-block";
      document.getElementById("logoutBtn").style.display = "none";
      $needLogin.style.display = "inline";
      $loginLink.style.display = "inline-block";
    }
    updateButtonState();
  }

  // ====== Simple 3D preview (existing logic; unchanged) ======
  const ctx = canvas.getContext("2d");
  function clearCanvas() {
    ctx.fillStyle = "#0b1220";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  function drawIsoCube(x, y, z, s, color) {
    const isoX = (x - z) * s;
    const isoY = (x + z) * s * 0.5 - y * s;

    // top
    ctx.beginPath();
    ctx.moveTo(isoX, isoY - s);
    ctx.lineTo(isoX + s, isoY - s * 0.5);
    ctx.lineTo(isoX, isoY);
    ctx.lineTo(isoX - s, isoY - s * 0.5);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();

    // left
    ctx.beginPath();
    ctx.moveTo(isoX - s, isoY - s * 0.5);
    ctx.lineTo(isoX, isoY);
    ctx.lineTo(isoX, isoY + s);
    ctx.lineTo(isoX - s, isoY + s * 0.5);
    ctx.closePath();
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fill();

    // right
    ctx.beginPath();
    ctx.moveTo(isoX + s, isoY - s * 0.5);
    ctx.lineTo(isoX, isoY);
    ctx.lineTo(isoX, isoY + s);
    ctx.lineTo(isoX + s, isoY + s * 0.5);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fill();
  }

  function pickColor(blockId) {
    // keep existing: stable-ish palette by id hash
    const s = String(blockId || "");
    let h = 0;
    for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i)) >>> 0;
    const r = 60 + (h & 0x7F);
    const g = 60 + ((h>>7) & 0x7F);
    const b = 60 + ((h>>14) & 0x7F);
    return `rgb(${r},${g},${b})`;
  }

  function renderPreview(blocks, yawQuarter) {
    clearCanvas();
    if (!Array.isArray(blocks) || blocks.length === 0) return;

    // normalize coords
    let minX=Infinity, minY=Infinity, minZ=Infinity;
    let maxX=-Infinity, maxY=-Infinity, maxZ=-Infinity;

    const pts = [];
    for (const b of blocks) {
      const x = Number(b.x || 0);
      const y = Number(b.y || 0);
      const z = Number(b.z || 0);
      minX=Math.min(minX,x); minY=Math.min(minY,y); minZ=Math.min(minZ,z);
      maxX=Math.max(maxX,x); maxY=Math.max(maxY,y); maxZ=Math.max(maxZ,z);
      pts.push({x,y,z,bid:b.block || b.id || b.blockId || ""});
    }

    const w = canvas.width, h = canvas.height;
    const spanX = (maxX-minX+1);
    const spanY = (maxY-minY+1);
    const spanZ = (maxZ-minZ+1);

    // scale heuristic
    const s = Math.max(2, Math.min(10, Math.floor(520 / (spanX + spanZ + spanY*0.5 + 8))));
    const cx = (minX+maxX)/2;
    const cy = (minY+maxY)/2;
    const cz = (minZ+maxZ)/2;

    // yaw rotate
    function rot(p) {
      let {x,y,z} = p;
      const dx = x - cx, dz = z - cz;
      if (yawQuarter === 1) { x = cx + dz; z = cz - dx; }
      else if (yawQuarter === 2) { x = cx - dx; z = cz - dz; }
      else if (yawQuarter === 3) { x = cx - dz; z = cz + dx; }
      return {x,y,z};
    }

    const drawn = pts.map(p => {
      const rp = rot(p);
      return { x: rp.x, y: rp.y, z: rp.z, bid: p.bid };
    });

    // sort back->front
    drawn.sort((a,b)=> (a.x+a.z) - (b.x+b.z) || (a.y-b.y));

    ctx.save();
    // center translate
    ctx.translate(w/2, h/2 + 120);

    for (const p of drawn) {
      drawIsoCube(p.x - cx, p.y - cy, p.z - cz, s, pickColor(p.bid));
    }

    ctx.restore();
  }

  function updatePreviewFromJson() {
    if (!parsedJson) return;
    const info = {
      blocks: Array.isArray(parsedJson.blocks) ? parsedJson.blocks.length : 0,
      unitId: parsedJson.unitId || parsedJson.unit_id || "",
      size: parsedJson.size || parsedJson.dim || null,
      hasFrontYaw: parsedJson.frontYaw != null,
      yaw_offset_quarter: Number($yawOffset.value || "0"),
    };
    setPreview(info);
    try {
      renderPreview(parsedJson.blocks || [], Number($yawOffset.value || "0"));
    } catch(_) {}
  }

  $yawOffset.addEventListener("change", () => {
    updatePreviewFromJson();
  });

  $title.addEventListener("input", updateButtonState);

  $file.addEventListener("change", async () => {
    const f = $file.files && $file.files[0];
    parsedJson = null;
    jsonDirty = true;
    $afterSuccess.style.display = "none";
    if ($submitMsg) $submitMsg.textContent = "";
    if (!f) {
      setPreview({});
      setResult("未送信");
      updateButtonState();
      return;
    }

    try {
      const txt = await f.text();
      const obj = JSON.parse(txt);
      const err = validateMobCrafterJson(obj);
      if (err) {
        parsedJson = null;
        setResult({ ok:false, error:"invalid_json", message: err });
        setPreview({ error: err });
      } else {
        parsedJson = obj;
        setResult("OK: JSON読み込み完了（未送信）");
        updatePreviewFromJson();
      }
    } catch(e) {
      parsedJson = null;
      setResult({ ok:false, error:"parse_fail", message: String(e?.message || e) });
      setPreview({ error: "parse_fail" });
    }
    updateButtonState();
  });

  // initial
  clearCanvas();
  setPreview({});
  setResult("未送信");

  (async () => {
    const me = await whoami();
    setAuthUI(me);
  })();

  // ---- Submit ----
  $btn.addEventListener("click", async () => {
    if (!parsedJson) return;

    // 未ログインならログイン導線を出して終了
    if (!isLoggedIn) {
      $loginLink.style.display = "inline-block";
      setResult({ ok:false, error:"login_required" });
      if ($submitMsg) $submitMsg.textContent = "❌ ログインが必要です";
      updateButtonState();
      return;
    }

    const email = normEmail(loggedInEmail);
    const authorName = email ? email.split("@")[0].slice(0, 60) : "unknown";

    const commonMeta = {
      title: $title.value.trim(),
      description: $desc.value.trim(),
      tags: ($tags.value||"").split(",").map(s=>s.trim()).filter(Boolean),
      mod_version: $mv.value.trim(),
      yaw_offset_quarter: Number($yawOffset.value || "0"),
    };

    let payload = null;

    if(!isEditMode){
      payload = {
        ...commonMeta,

        // ★追加：サーバ側で author を確実に保存できる
        author_name: authorName,
        author_email: email,

        // 任意メタ
        mc_version: ($mc.value||"").trim() || null,

        // 本体
        unit_json: parsedJson,
      };
    } else {
      payload = {
        ...commonMeta,
        mc_version: ($mc.value||"").trim() || null,
        unit_json: parsedJson,
      };
    }

    try {
      if ($submitMsg) $submitMsg.textContent = "送信中…";
      $afterSuccess.style.display = "none";

      const endpoint = isEditMode ? ("/api/my/submissions/" + encodeURIComponent(editId)) : "/api/submit";
      const method = isEditMode ? "PUT" : "POST";

      const resp = await fetch(endpoint, {
        method,
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify(payload),
        credentials:"include",
      });
      const data = await resp.json().catch(()=>null);

      setResult({ http: resp.status, ...data });

      // 成功時表示（自動遷移は禁止。リンクはユーザーが選んで遷移）
      try {
        // 送信結果をボタン直下にも表示
        if ($submitMsg) $submitMsg.textContent = resp.ok ? "✅ 送信完了" : "❌ 送信失敗";

        if ($afterSuccess && resp.ok) {
          // Worker 側の返却キー揺れに耐える（unit_id / id / submission_id etc）
          const submissionId =
            (data && (data.submission_id || data.submissionId || data.id || data.submission_id)) || "";
          lastSubmissionId = String(submissionId || "");

          const unitId =
            (data && (data.unit_id || data.unitId || data.unit_id)) || "";
          const unitUrl = unitId ? ("/unit?id=" + encodeURIComponent(unitId)) : "";
          const backUrl = "/";

          $afterSuccess.style.display = "block";
          $afterSuccess.innerHTML = `
            <div>✅ 送信完了。${unitUrl ? `<a href="${unitUrl}">個別ページを見る</a>` : ``} / <a href="${backUrl}">一覧に戻る</a></div>
            <div style="margin-top:10px; padding-top:10px; border-top:1px solid #e5e7eb;"></div>
            <div style="margin-top:8px;">
              <div style="font-weight:600; margin-bottom:6px;">スクリーンショット（任意）</div>
              <div class="mini" style="margin-bottom:8px;">※ 送信した JSON の投稿に紐づけてアップロードします。画像は最大 8MB。</div>

              <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                <input id="screenFile" type="file" accept="image/*" />
                <button id="btnUploadScreen" class="primary" style="padding:10px 14px;" disabled>スクショをアップロード</button>
              </div>

              <div style="margin-top:8px; display:flex; gap:14px; align-items:center; flex-wrap:wrap;">
                <div class="mini" style="font-weight:600;">一覧サムネ:</div>
                <label class="mini" style="display:flex; gap:6px; align-items:center;">
                  <input type="radio" name="thumbMode" value="3d" checked />
                  3D（従来）
                </label>
                <label class="mini" style="display:flex; gap:6px; align-items:center;">
                  <input type="radio" name="thumbMode" value="screen" />
                  このスクショ
                </label>
              </div>

              <pre id="screenResult" style="margin-top:10px;">未アップロード</pre>
            </div>
          `;

          // --- upload wiring ---
          const $sf = document.getElementById("screenFile");
          const $ub = document.getElementById("btnUploadScreen");
          const $sr = document.getElementById("screenResult");

          if ($sf && $ub && $sr) {
            $sf.addEventListener("change", () => {
              $ub.disabled = !($sf.files && $sf.files[0]);
            });

            $ub.addEventListener("click", async () => {
              try {
                if (!lastSubmissionId) {
                  $sr.textContent = "submission_id が取得できていません（送信結果を確認してください）";
                  return;
                }
                const f = $sf.files && $sf.files[0];
                if (!f) {
                  $sr.textContent = "ファイルが選択されていません";
                  return;
                }

                const modeEl = document.querySelector('input[name="thumbMode"]:checked');
                const thumbMode = modeEl ? String(modeEl.value) : "3d";
                const setThumb = (thumbMode === "screen");

                const fd = new FormData();
                fd.append("file", f);
                if (setThumb) fd.append("set_thumb", "1"); // Worker 側でサムネ指定として扱う

                $sr.textContent = "アップロード中…";

                const r = await fetch(`/api/submissions/${encodeURIComponent(lastSubmissionId)}/screens`, {
                  method: "POST",
                  body: fd,
                  credentials: "include",
                });

                const j = await r.json().catch(() => ({}));
                $sr.textContent = JSON.stringify({ http: r.status, ...j }, null, 2);

                if (r.ok && j && j.ok) {
                  // 送信ボタン直下にも反映
                  if ($submitMsg) {
                    $submitMsg.textContent = setThumb ? "✅ 送信完了（スクショをサムネに設定）" : "✅ 送信完了（スクショ追加）";
                  }
                }
              } catch (e) {
                $sr.textContent = "アップロード失敗: " + (e?.message || String(e));
              }
            });
          }
        }
      } catch (_) {}
    } catch (e) {
      setResult("送信失敗: " + (e?.message || String(e)));
      if ($submitMsg) $submitMsg.textContent = "❌ 送信失敗";
    }
  });
})();
</script>

</body>
</html>
