<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MobCrafter - Unit Submit</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, sans-serif; margin: 24px; }
    .card { max-width: 720px; border: 1px solid #ddd; border-radius: 12px; padding: 16px; }
    label { display:block; margin-top: 12px; font-weight: 600; }
    input[type="text"], textarea { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 8px; }
    textarea { min-height: 84px; }
    .row { display:flex; gap: 12px; }
    .row > div { flex: 1; }
    button { margin-top: 14px; padding: 10px 14px; border: 0; border-radius: 10px; cursor:pointer; }
    button.primary { background:#111; color:#fff; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    pre { white-space: pre-wrap; word-break: break-word; background:#f6f6f6; padding: 12px; border-radius: 10px; }
    .hint { color:#555; font-size: 13px; margin-top: 8px; }
    canvas { margin-top: 8px; }
  </style>
</head>
<body>

<div class="card">
  <h1>ユニット投稿</h1>
  <div class="hint">
    Cloudflare Access ログイン後に投稿できます。
  </div>

  <label>JSONファイル</label>
  <input id="file" type="file" accept=".json,application/json" />

  <label>タイトル</label>
  <input id="title" type="text" placeholder="例: Sephiroth Unit v1" />

  <label>説明</label>
  <textarea id="description" placeholder="説明（任意）"></textarea>

  <div class="row">
    <div>
      <label>タグ（カンマ区切り）</label>
      <input id="tags" type="text" placeholder="boss, ff7, sword" />
    </div>
    <div>
      <label>mod_version（任意）</label>
      <input id="modVersion" type="text" placeholder="1.0.0" />
    </div>
  </div>

  <button id="btn" class="primary" disabled>送信</button>

  <label>プレビュー（情報）</label>
  <pre id="preview">{}</pre>

  <label>3Dイメージ（簡易）</label>
  <canvas id="canvas" width="420" height="420"
    style="border:1px solid #ccc; border-radius:10px;"></canvas>
  <div class="hint">
    ※ 形状確認用の簡易表示です（色・質感は実物と異なります）
  </div>

  <label>結果</label>
  <pre id="result">未送信</pre>
</div>

<script>
(() => {
  const $file = document.getElementById("file");
  const $title = document.getElementById("title");
  const $desc  = document.getElementById("description");
  const $tags  = document.getElementById("tags");
  const $mv    = document.getElementById("modVersion");
  const $btn   = document.getElementById("btn");
  const $prev  = document.getElementById("preview");
  const $res   = document.getElementById("result");
  const canvas = document.getElementById("canvas");

  let parsedJson = null;

  function setPreview(v) {
    $prev.textContent = typeof v === "string" ? v : JSON.stringify(v, null, 2);
  }
  function setResult(v) {
    $res.textContent = typeof v === "string" ? v : JSON.stringify(v, null, 2);
  }
  function updateButtonState() {
    $btn.disabled = !(parsedJson && ($title.value || "").trim());
  }

  function validateMobCrafterJson(obj) {
    if (!obj || typeof obj !== "object") return "JSONがオブジェクトではありません";
    if (!Array.isArray(obj.blocks)) return "blocks 配列がありません";
    if (obj.blocks.length === 0) return "blocks が空です";
    if (obj.blocks.length > 200000) return "blocks が多すぎます（200k超）";

    for (let i = 0; i < Math.min(obj.blocks.length, 1000); i++) {
      const b = obj.blocks[i];
      if (typeof b.dx !== "number" || typeof b.dy !== "number" || typeof b.dz !== "number") {
        return `blocks[${i}] に dx/dy/dz がありません`;
      }
      if (typeof b.blockId !== "string") {
        return `blocks[${i}] に blockId がありません`;
      }
    }
    return null;
  }

  function analyzeBlocks(blocks) {
    let minX = Infinity, minY = Infinity, minZ = Infinity;
    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

    for (const b of blocks) {
      minX = Math.min(minX, b.dx);
      minY = Math.min(minY, b.dy);
      minZ = Math.min(minZ, b.dz);
      maxX = Math.max(maxX, b.dx);
      maxY = Math.max(maxY, b.dy);
      maxZ = Math.max(maxZ, b.dz);
    }
    return {
      count: blocks.length,
      sizeX: maxX - minX + 1,
      sizeY: maxY - minY + 1,
      sizeZ: maxZ - minZ + 1,
      minX, minY, minZ
    };
  }

  // ===== frontYaw → 90度単位 (0,1,2,3) =====
  // ※ “正解の定義”は作品により揺れるので、まずは90度刻みで合わせる
  function yawToQuarterTurns(frontYaw){
    if(frontYaw == null) return 0;
    const y = Number(frontYaw);
    if(!Number.isFinite(y)) return 0;

    let deg = y % 360;
    if(deg < 0) deg += 360;

    // -90 が来るケースを想定しているので、ここで基準を合わせる補正を入れる
    // まずは「-90 => 右90回転」になるように +90 してから丸める
    // （合わなければここを ±90/180 で調整すれば一発で直る）
    deg = (deg + 90) % 360;

    return (Math.round(deg / 90) % 4);
  }

  // q=0:そのまま, q=1:90, q=2:180, q=3:270
  function rotateXZ(x, z, q){
    switch(q){
      case 1: return {x: z,  z: -x};
      case 2: return {x: -x, z: -z};
      case 3: return {x: -z, z: x};
      default:return {x, z};
    }
  }

  function hashColor(id){
    let h=0;
    for(let i=0;i<id.length;i++) h=(h*31 + id.charCodeAt(i))|0;
    const r = 110 + (h & 90);
    const g = 110 + ((h>>8)&90);
    const b = 110 + ((h>>16)&90);
    return {r,g,b};
  }

  // “面”で描く：上面＋左面＋右面（軽量等角）
  function drawIsoCube(ctx, x, y, z, s, col){
    const sx = (x - z) * s;
    const sy = (x + z) * s * 0.5 - y * s;

    const top = `rgb(${Math.min(255,col.r+35)},${Math.min(255,col.g+35)},${Math.min(255,col.b+35)})`;
    const left= `rgb(${Math.max(0,col.r-10)},${Math.max(0,col.g-10)},${Math.max(0,col.b-10)})`;
    const right=`rgb(${Math.max(0,col.r-30)},${Math.max(0,col.g-30)},${Math.max(0,col.b-30)})`;

    // 上面
    ctx.fillStyle = top;
    ctx.beginPath();
    ctx.moveTo(sx, sy - s*0.5);
    ctx.lineTo(sx + s, sy);
    ctx.lineTo(sx, sy + s*0.5);
    ctx.lineTo(sx - s, sy);
    ctx.closePath();
    ctx.fill();

    // 左面
    ctx.fillStyle = left;
    ctx.beginPath();
    ctx.moveTo(sx - s, sy);
    ctx.lineTo(sx, sy + s*0.5);
    ctx.lineTo(sx, sy + s*0.5 + s);
    ctx.lineTo(sx - s, sy + s);
    ctx.closePath();
    ctx.fill();

    // 右面
    ctx.fillStyle = right;
    ctx.beginPath();
    ctx.moveTo(sx + s, sy);
    ctx.lineTo(sx, sy + s*0.5);
    ctx.lineTo(sx, sy + s*0.5 + s);
    ctx.lineTo(sx + s, sy + s);
    ctx.closePath();
    ctx.fill();
  }

  function drawBlocksIso(canvas, blocks, info, frontYaw){
    const ctx = canvas.getContext("2d");
    const w = canvas.width, h = canvas.height;

    // 背景
    ctx.clearRect(0,0,w,h);
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,"rgba(37,99,235,.10)");
    g.addColorStop(1,"rgba(22,163,74,.08)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // 間引き（submitは軽めでOK）
    const MAX_DRAW = 12000;
    let list = blocks;
    if (blocks.length > MAX_DRAW) {
      const step = Math.ceil(blocks.length / MAX_DRAW);
      list = blocks.filter((_,i)=>i%step===0);
    }

    // 回転（90度単位）
    const q = yawToQuarterTurns(frontYaw);

    // サイズ（回転後の見た目に合わせてざっくり）
    const spanX = info.sizeX + info.sizeZ;
    const spanY = info.sizeY;

    const s = Math.max(2, Math.min(w/(spanX+6), h/(spanY+10)) * 1.6);

    const ox = w*0.5;
    const oy = h*0.80;

    // ソート：奥→手前・下→上寄り（簡易）
    const sorted = [...list].sort((a,b)=>
      (a.dx+a.dz) - (b.dx+b.dz) || (a.dy - b.dy)
    );

    ctx.save();
    ctx.translate(ox, oy);

    for (const b of sorted) {
      const rx = b.dx - info.minX;
      const ry = b.dy - info.minY;
      const rz = b.dz - info.minZ;

      const r = rotateXZ(rx, rz, q);
      const col = hashColor(b.blockId);

      drawIsoCube(ctx, r.x, ry, r.z, s, col);
    }

    ctx.restore();
  }

  $file.addEventListener("change", async () => {
    parsedJson = null;
    setResult("未送信");
    setPreview("{}");

    const f = $file.files && $file.files[0];
    if (!f) return;

    if (f.size > 2_200_000) {
      setPreview("ファイルが大きすぎます（約2MB超）");
      return;
    }

    try {
      const obj = JSON.parse(await f.text());
      const err = validateMobCrafterJson(obj);
      if (err) { setPreview(err); return; }

      parsedJson = obj;

      if (!$title.value.trim()) {
        $title.value = f.name.replace(/\.json$/i,"");
      }

      const info = analyzeBlocks(obj.blocks);

      setPreview({
        file: { name: f.name, size: f.size },
        blocks: info.count,
        size: `${info.sizeX} x ${info.sizeY} x ${info.sizeZ}`,
        frontYaw: (obj.frontYaw ?? null),
        note: info.count > 12000 ? "ブロック数が多いため描画は間引き表示です" : ""
      });

      // ★ indexと同系統の等角キューブ描画に変更
      drawBlocksIso(canvas, obj.blocks, info, obj.frontYaw);

    } catch (e) {
      setPreview("JSONとして読み込めません: " + (e?.message || String(e)));
    }

    updateButtonState();
  });

  [$title,$desc,$tags,$mv].forEach(el =>
    el.addEventListener("input", updateButtonState)
  );

  $btn.addEventListener("click", async () => {
    if (!parsedJson) return;

    const payload = {
      title: $title.value.trim(),
      description: $desc.value.trim(),
      tags: ($tags.value||"").split(",").map(s=>s.trim()).filter(Boolean),
      mod_version: $mv.value.trim(),
      json: parsedJson
    };

    setResult("送信中...");

    try {
      const resp = await fetch("/api/submit", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        credentials: "include"
      });

      const text = await resp.text();
      let data;
      try { data = JSON.parse(text); } catch { data = { raw: text }; }

      setResult({ http: resp.status, ok: resp.ok, ...data });
    } catch (e) {
      setResult("送信失敗: " + (e?.message || String(e)));
    }
  });
})();
</script>

</body>
</html>
