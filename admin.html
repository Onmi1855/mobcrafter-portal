<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MobCrafter Admin - Submissions</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, sans-serif; margin: 24px; }
    .wrap { max-width: 980px; margin: 0 auto; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin-top: 12px; }
    h1 { margin: 0 0 8px; }
    .row { display:flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 0 0 auto; }
    select, button, input, textarea { padding: 10px; border-radius: 10px; border: 1px solid #ccc; }
    textarea { width: 100%; min-height: 200px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    button { cursor: pointer; }
    button.primary { background:#111; color:#fff; border: 0; }
    button.danger { background:#b00020; color:#fff; border: 0; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    pre { background:#f6f6f6; padding: 12px; border-radius: 10px; white-space: pre-wrap; word-break: break-word; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border-bottom: 1px solid #eee; padding: 10px; vertical-align: top; }
    th { text-align: left; color:#444; font-size: 13px; }
    .muted { color:#666; font-size: 13px; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; background:#eee; font-size: 12px; }
    .pill.red { background:#ffe3e3; }
    .tags { display:flex; flex-wrap: wrap; gap: 6px; }
    .tag { background:#eef; border:1px solid #dde; padding:2px 8px; border-radius: 999px; font-size: 12px; }
    a { color: #0b57d0; }
    .btnlink { display:inline-flex; align-items:center; gap:6px; text-decoration:none; padding:8px 10px; border-radius:10px; border:1px solid #ccc; }
    dialog { border: 1px solid #ddd; border-radius: 12px; padding: 14px; width: min(820px, 96vw); }
    dialog::backdrop { background: rgba(0,0,0,.25); }
    .dlghead { display:flex; justify-content: space-between; align-items:center; gap: 10px; }
    .dlgtitle { font-weight: 800; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 860px) { .grid2 { grid-template-columns: 1fr; } }
    .mini { font-size: 12px; color:#666; }

    /* ===== B: thumb ===== */
    .thumbwrap{
      width: 220px;
      height: 140px;
      border-radius: 12px;
      border: 1px solid #e5e7eb;
      overflow: hidden;
      background: linear-gradient(180deg, #e6f0ff, #f5f9ff);
      display:flex;
      align-items:center;
      justify-content:center;
    }
    canvas.thumb{
      width: 100%;
      height: 140px;
      image-rendering: pixelated;
      display:block;
    }
    img.thumbimg{
      width:100%;
      height:140px;
      object-fit:cover;
      display:block;
    }
    .contentRow{
      display:flex;
      gap:12px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .contentText{
      flex: 1 1 240px;
      min-width: 240px;
    }
  </style>
</head>
<body>
<div class="wrap">
  <h1>MobCrafter 管理画面</h1>
  <div class="muted">
    ※ 管理者のみ。APIは <code>/api/admin/*</code> を叩きます（同一オリジン）。<br>
    ※ Cloudflare Access（Google OAuth）で <code>mobcrafter.net/api/admin*</code> を保護している前提です。
  </div>

  <div class="card">
    <div class="row">
      <label>
        表示ステータス：
        <select id="status">
          <option value="pending" selected>pending（未承認）</option>
          <option value="approved">approved（承認済）</option>
          <option value="rejected">rejected（却下）</option>
        </select>
      </label>

      <label>
        <input id="includeDeleted" type="checkbox" />
        削除済みも含める
      </label>

      <button id="reload" class="primary">再読み込み</button>

      <label>
        検索（サーバー）：<input id="q" type="text" placeholder="例: ff7 / Sephiroth" />
      </label>

      <span class="pill" id="count">0件</span>
    </div>
    <div class="mini" style="margin-top:8px;">
      ※ 検索は Worker の <code>?query=</code> を使用（大量でも軽い）。削除済み表示は <code>?include_deleted=1</code>。
    </div>
  </div>

  <div class="card">
    <div class="muted">ログ</div>
    <pre id="log">ready</pre>
  </div>

  <div class="card">
    <div class="muted">一覧</div>
    <div id="list"></div>
  </div>
</div>

<!-- 編集ダイアログ -->
<dialog id="dlgEdit">
  <div class="dlghead">
    <div class="dlgtitle">編集</div>
    <button id="dlgClose">閉じる</button>
  </div>
  <div class="mini" id="dlgInfo" style="margin:6px 0 10px;"></div>

  <div class="grid2">
    <div>
      <div class="mini">タイトル（最大80）</div>
      <input id="editTitle" type="text" />
    </div>
    <div>
      <div class="mini">タグ（空白/カンマ区切り）</div>
      <input id="editTags" type="text" />
    </div>
  </div>

  <div style="margin-top:10px;">
    <div class="mini">説明（最大2000）</div>
    <input id="editDesc" type="text" />
  </div>

  <div style="margin-top:12px;">
    <div class="mini">JSON差し替え（貼り付け）</div>
    <textarea id="editJson" placeholder='{"blocks":[...]} だけでもOK'></textarea>
    <div class="mini">※ unitId/id はサーバー側で固定に上書きされます。</div>
  </div>

  <div class="row" style="margin-top:12px;">
    <button id="btnSaveMeta" class="primary">メタ保存</button>
    <button id="btnSaveJson" class="primary">JSON保存</button>
    <span class="pill" id="dlgStatus">-</span>
  </div>
</dialog>

<script>
(() => {
  // ★ Access セッション確立（admin叩く前に whoami を踏む）
  async function warmupAccessSession(){
    try{
      const r = await fetch("/api/whoami", {
        cache: "no-store",
        credentials: "include",
        redirect: "manual",
      });

      if (r.type === "opaqueredirect" || r.status === 0) {
        location.href = "/api/login?next=" + encodeURIComponent("/admin");
        return false;
      }

      const data = await r.json().catch(()=>null);
      if (!data || !data.email) {
        location.href = "/api/login?next=" + encodeURIComponent("/admin");
        return false;
      }
      return true;
    }catch(e){
      location.href = "/api/login?next=" + encodeURIComponent("/admin");
      return false;
    }
  }

  const API_BASE = "/api/admin";

  // B: 画像/JSON取得（adminは常に private を使う）
  const API_PRIVATE_SCREEN = (screenId) => `/api/screens/${encodeURIComponent(screenId)}`;
  const API_OWNER_JSON = (id) => `/api/submissions/${encodeURIComponent(id)}/json`;

  const $status = document.getElementById("status");
  const $reload = document.getElementById("reload");
  const $q = document.getElementById("q");
  const $includeDeleted = document.getElementById("includeDeleted");
  const $count = document.getElementById("count");
  const $log = document.getElementById("log");
  const $list = document.getElementById("list");

  const $dlg = document.getElementById("dlgEdit");
  const $dlgClose = document.getElementById("dlgClose");
  const $dlgInfo = document.getElementById("dlgInfo");
  const $editTitle = document.getElementById("editTitle");
  const $editTags  = document.getElementById("editTags");
  const $editDesc  = document.getElementById("editDesc");
  const $editJson  = document.getElementById("editJson");
  const $btnSaveMeta = document.getElementById("btnSaveMeta");
  const $btnSaveJson = document.getElementById("btnSaveJson");
  const $dlgStatus = document.getElementById("dlgStatus");

  let items = [];
  let currentEdit = null; // {id, item}

  function log(v) {
    $log.textContent = typeof v === "string" ? v : JSON.stringify(v, null, 2);
  }

  function esc(s) {
    return String(s ?? "").replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[m]));
  }

  function parseTags(tags) {
    try {
      if (Array.isArray(tags)) return tags;
      if (typeof tags === "string") {
        const t = tags.trim();
        if (!t) return [];
        if (t.startsWith("[") && t.endsWith("]")) return JSON.parse(t);
        return t.split(/[, \t\r\n]+/).map(s=>s.trim()).filter(Boolean);
      }
    } catch {}
    return [];
  }

  function buildListQuery() {
    const status = ($status.value || "pending").trim();
    const q = ($q.value || "").trim();
    const includeDeleted = $includeDeleted.checked ? "1" : "0";

    const params = new URLSearchParams();
    params.set("status", status);
    if (includeDeleted === "1") params.set("include_deleted", "1");
    if (q) params.set("query", q);

    return `submissions?${params.toString()}`;
  }

  async function api(path, method, body) {
    const u = API_BASE.replace(/\/+$/,"") + "/" + String(path).replace(/^\/+/,"");
    const init = {
      method,
      credentials: "include",
      headers: { "Accept": "application/json" }
    };
    if (body !== undefined) {
      init.headers["Content-Type"] = "application/json";
      init.body = JSON.stringify(body);
    }
    const r = await fetch(u, init);
    const text = await r.text();
    let data;
    try { data = JSON.parse(text); } catch { data = { raw: text }; }
    if (!r.ok) throw { http: r.status, data };
    return data;
  }

  // =========================================================
  // B: 3D thumb (index.html から移植・最小セット)
  // =========================================================
  const PALETTE_URL = "/assets/palette.v1.json";
  const PALETTE_VER = "v1";
  const PALETTE_LS_KEY = `mcPalette:${PALETTE_VER}`;
  let PALETTE_MAP = null;

  function parseColorString(s){
    if(!s) return null;
    const v = String(s).trim();
    const hex = /^#([0-9a-f]{6})$/i.exec(v);
    if(hex){
      const n = parseInt(hex[1], 16);
      return { r:(n>>16)&255, g:(n>>8)&255, b:n&255, a:1 };
    }
    const rgba = /^rgba?\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})(?:\s*,\s*([0-9]*\.?[0-9]+))?\s*\)$/i.exec(v);
    if(rgba){
      const r = Math.max(0, Math.min(255, parseInt(rgba[1],10)));
      const g = Math.max(0, Math.min(255, parseInt(rgba[2],10)));
      const b = Math.max(0, Math.min(255, parseInt(rgba[3],10)));
      const a = rgba[4] == null ? 1 : Math.max(0, Math.min(1, parseFloat(rgba[4])));
      return {r,g,b,a};
    }
    return null;
  }

  async function loadPalette(){
    if(PALETTE_MAP) return PALETTE_MAP;
    try{
      const cached = localStorage.getItem(PALETTE_LS_KEY);
      if(cached){
        const obj = JSON.parse(cached);
        if(obj && typeof obj === "object"){
          PALETTE_MAP = obj;
          return PALETTE_MAP;
        }
      }
    }catch(e){}
    try{
      const r = await fetch(`${PALETTE_URL}?v=${encodeURIComponent(PALETTE_VER)}`, { cache:"no-store" });
      if(r.ok){
        const obj = await r.json();
        if(obj && typeof obj === "object"){
          PALETTE_MAP = obj;
          try{ localStorage.setItem(PALETTE_LS_KEY, JSON.stringify(obj)); }catch(e){}
          return PALETTE_MAP;
        }
      }
    }catch(e){}
    PALETTE_MAP = {};
    return PALETTE_MAP;
  }

  function paletteLookup(blockId){
    if(!PALETTE_MAP) return null;
    const k = String(blockId||"").trim().toLowerCase();
    return parseColorString(PALETTE_MAP[k]);
  }

  function pickBaseColor(blockId){
    const p = paletteLookup(blockId);
    if(p) return p;

    const raw = String(blockId||"").toLowerCase();
    const id = raw.includes(":") ? raw.split(":")[1] : raw;

    if (id.includes("glass") || id.includes("ice")) return {r: 170, g: 210, b: 230, a: 0.55};
    if (id.includes("leaves") || id.includes("leaf") || id.includes("moss") || id.includes("vine") || id.includes("grass")) return {r: 90, g: 150, b: 90, a: 0.95};
    if (id.includes("log") || id.includes("wood") || id.includes("planks") || id.includes("bamboo")) return {r: 160, g: 125, b: 85, a: 0.95};
    if (id.includes("dirt") || id.includes("sand") || id.includes("gravel") || id.includes("clay") || id.includes("mud")) return {r: 160, g: 145, b: 110, a: 0.98};
    if (id.includes("stone") || id.includes("deepslate") || id.includes("andesite") || id.includes("diorite") || id.includes("granite") || id.includes("cobble") || id.includes("tuff") || id.includes("slate")) return {r: 140, g: 145, b: 155, a: 0.98};
    if (id.includes("iron") || id.includes("anvil") || id.includes("chain") || id.includes("rail") || id.includes("metal")) return {r: 170, g: 175, b: 185, a: 0.98};
    if (id.includes("copper") || id.includes("bronze")) return {r: 190, g: 120, b: 80, a: 0.98};
    if (id.includes("gold")) return {r: 210, g: 185, b: 90, a: 0.98};
    if (id.includes("diamond")) return {r: 120, g: 210, b: 220, a: 0.98};
    if (id.includes("emerald")) return {r: 70, g: 200, b: 120, a: 0.98};
    if (id.includes("lapis")) return {r: 70, g: 110, b: 200, a: 0.98};
    if (id.includes("redstone")) return {r: 190, g: 70, b: 70, a: 0.98};

    let h=0; for(let i=0;i<raw.length;i++) h=(h*31 + raw.charCodeAt(i))|0;
    return { r:120 + (h & 70), g:120 + ((h>>8)&70), b:120 + ((h>>16)&70), a:0.98 };
  }

  function isAirBlock(blockId){
    const s = String(blockId||"").trim().toLowerCase();
    return s === "minecraft:air" || s.endsWith(":air");
  }

  function drawIsoCube(ctx, x, y, z, s, col, stroke){
    const sx = (x - z) * s;
    const sy = (x + z) * s * 0.5 - y * s;

    const a = (col.a == null ? 1 : col.a);
    const top = `rgba(${Math.min(255,col.r+30)},${Math.min(255,col.g+30)},${Math.min(255,col.b+30)},${a})`;
    const left= `rgba(${Math.max(0,col.r-10)},${Math.max(0,col.g-10)},${Math.max(0,col.b-10)},${a})`;
    const right=`rgba(${Math.max(0,col.r-25)},${Math.max(0,col.g-25)},${Math.max(0,col.b-25)},${a})`;

    ctx.fillStyle = top;
    ctx.beginPath();
    ctx.moveTo(sx, sy - s*0.5);
    ctx.lineTo(sx + s, sy);
    ctx.lineTo(sx, sy + s*0.5);
    ctx.lineTo(sx - s, sy);
    ctx.closePath();
    ctx.fill();
    if (stroke){
      ctx.strokeStyle = "rgba(15,23,42,.10)";
      ctx.lineWidth = Math.max(1, s*0.06);
      ctx.stroke();
    }

    ctx.fillStyle = left;
    ctx.beginPath();
    ctx.moveTo(sx - s, sy);
    ctx.lineTo(sx, sy + s*0.5);
    ctx.lineTo(sx, sy + s*0.5 + s);
    ctx.lineTo(sx - s, sy + s);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = right;
    ctx.beginPath();
    ctx.moveTo(sx + s, sy);
    ctx.lineTo(sx, sy + s*0.5);
    ctx.lineTo(sx, sy + s*0.5 + s);
    ctx.lineTo(sx + s, sy + s);
    ctx.closePath();
    ctx.fill();
  }

  function drawIso(canvas, blocks, yawDeg){
    const ctx = canvas.getContext("2d");
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    if(!Array.isArray(blocks) || blocks.length === 0){
      ctx.fillStyle = "rgba(15,23,42,.35)";
      ctx.font = "12px sans-serif";
      ctx.fillText("No blocks", 10, 20);
      return;
    }

    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,"rgba(37,99,235,.10)");
    g.addColorStop(1,"rgba(22,163,74,.08)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    const yaw = (Number(yawDeg||0) % 360) * Math.PI/180;
    const cos = Math.cos(yaw), sin = Math.sin(yaw);

    const pts = [];
    for(const b of blocks){
      const bid = String(b.blockId||"");
      if(isAirBlock(bid)) continue;

      const x0 = Number(b.dx||0), y0 = Number(b.dy||0), z0 = Number(b.dz||0);
      const rx = x0*cos - z0*sin;
      const rz = x0*sin + z0*cos;

      const x = Math.round(rx);
      const z = Math.round(rz);
      const y = y0;

      const sx0 = (x - z);
      const sy0 = (x + z) * 0.5 - y;

      const minX = sx0 - 1;
      const maxX = sx0 + 1;
      const minY = sy0 - 0.5;
      const maxY = sy0 + 1.5;

      pts.push({x,y,z,bid,minX,maxX,minY,maxY});
    }

    if(pts.length === 0){
      ctx.fillStyle = "rgba(15,23,42,.35)";
      ctx.font = "12px sans-serif";
      ctx.fillText("No visible blocks", 10, 20);
      return;
    }

    let minPX=Infinity, maxPX=-Infinity, minPY=Infinity, maxPY=-Infinity;
    for(const p of pts){
      if(p.minX < minPX) minPX = p.minX;
      if(p.maxX > maxPX) maxPX = p.maxX;
      if(p.minY < minPY) minPY = p.minY;
      if(p.maxY > maxPY) maxPY = p.maxY;
    }

    const rangeX = Math.max(1e-6, (maxPX - minPX));
    const rangeY = Math.max(1e-6, (maxPY - minPY));
    const cx = (minPX + maxPX) * 0.5;
    const cy = (minPY + maxPY) * 0.5;

    const margin = 12;
    const s = Math.max(
      1.6,
      Math.min(
        (w - margin*2) / rangeX,
        (h - margin*2) / rangeY
      )
    );

    const ox = (w * 0.5) - (cx * s);
    const oy = (h * 0.5) - (cy * s);

    pts.sort((a,b)=> (a.x + a.z) - (b.x + b.z) || (a.y - b.y));

    const stroke = (s >= 3);

    ctx.save();
    ctx.translate(ox, oy);
    for(const p of pts){
      drawIsoCube(ctx, p.x, p.y, p.z, s, pickBaseColor(p.bid), stroke);
    }
    ctx.restore();
  }

  async function fetchUnitJsonForAdmin(id){
    const r = await fetch(API_OWNER_JSON(id), { cache:"no-store", credentials:"include" });
    if(!r.ok){
      const text = await r.text().catch(()=> "");
      throw new Error("json HTTP " + r.status + (text ? (" " + text.slice(0,120)) : ""));
    }
    return await r.json();
  }

  async function draw3DToCanvas(canvas, submissionId){
    const j = await fetchUnitJsonForAdmin(submissionId);
    await loadPalette();
    // index.html と同じ既定値（+270°）
    drawIso(canvas, j.blocks, 270);
  }

  function cacheBuster(it){
    return encodeURIComponent(String(it.updated_at || it.created_at || ""));
  }

  // render後に各行の thumb を実際に描画/取得
  async function enhanceThumbs(){
    const canvases = $list.querySelectorAll("canvas.thumb[data-submission-id]");
    for(const c of canvases){
      const id = c.getAttribute("data-submission-id");
      if(!id) continue;
      // 二重描画防止
      if (c.getAttribute("data-done") === "1") continue;
      c.setAttribute("data-done","1");
      (async ()=>{
        try{
          await draw3DToCanvas(c, id);
        }catch(e){}
      })();
    }

    const imgs = $list.querySelectorAll("img.thumbimg[data-screen-id][data-submission-id]");
    for(const img of imgs){
      const sid = img.getAttribute("data-screen-id");
      const subId = img.getAttribute("data-submission-id");
      if(!sid || !subId) continue;

      // srcセット（adminは常に private）
      if(!img.src){
        const v = img.getAttribute("data-v") || "";
        img.src = API_PRIVATE_SCREEN(sid) + (v ? ("?v=" + v) : "");
      }

      // 失敗したら 3Dへフォールバック
      img.addEventListener("error", async ()=>{
        try{
          const wrap = img.closest(".thumbwrap");
          if(!wrap) return;

          const canvas = document.createElement("canvas");
          canvas.className = "thumb";
          canvas.width = 480;
          canvas.height = 280;
          canvas.setAttribute("data-submission-id", subId);

          img.remove();
          wrap.appendChild(canvas);

          await draw3DToCanvas(canvas, subId);
        }catch(e){}
      }, { once:false });
    }
  }

  // =========================================================

  function render() {
    $count.textContent = `${items.length}件`;

    if (items.length === 0) {
      $list.innerHTML = `<div class="muted">該当なし</div>`;
      return;
    }

    const status = $status.value;
    const canModerate = (status === "pending");

    $list.innerHTML = `
      <table>
        <thead>
          <tr>
            <th style="width: 180px;">作成日時</th>
            <th>内容</th>
            <th style="width: 320px;">操作</th>
          </tr>
        </thead>
        <tbody>
          ${items.map(it => {
            const tags = parseTags(it.tags);
            const created = esc(it.created_at || "");
            const title = esc(it.title || "");
            const desc = esc(it.description || "");
            const author = esc(it.author_name || it.author_email || "");
            const mv = esc(it.mod_version || "");
            const id = esc(it.id || "");
            const no = it.submission_no != null ? String(it.submission_no) : "";
            const deleted = it.deleted_at ? true : false;

            const tagHtml = tags.length
              ? `<div class="tags">${tags.slice(0, 12).map(t=>`<span class="tag">${esc(t)}</span>`).join("")}</div>`
              : `<span class="muted">タグなし</span>`;

            const detailLink = no ? `<a class="btnlink" href="/u/${encodeURIComponent(no)}" target="_blank">公開詳細</a>` : "";
            const delPill = deleted ? `<span class="pill red">deleted</span>` : "";

            // ===== B: thumb decision =====
            const thumbMode = String(it.thumb_mode || "").toLowerCase();
            const screenId = (it.thumb_screen_id != null && it.thumb_screen_id !== "") ? String(it.thumb_screen_id) : "";
            const useScreen = (thumbMode === "screen" && screenId);

            const thumbHtml = useScreen
              ? `<div class="thumbwrap">
                   <img class="thumbimg"
                        alt=""
                        data-submission-id="${id}"
                        data-screen-id="${esc(screenId)}"
                        data-v="${cacheBuster(it)}"
                   />
                 </div>`
              : `<div class="thumbwrap">
                   <canvas class="thumb" width="480" height="280" data-submission-id="${id}"></canvas>
                 </div>`;

            return `
              <tr>
                <td>
                  <div>${created || "-"}</div>
                  <div class="muted">id: ${id}</div>
                  ${no ? `<div class="muted">no: ${esc(no)}</div>` : ""}
                  ${delPill ? `<div style="margin-top:6px;">${delPill}</div>` : ""}
                </td>
                <td>
                  <div class="contentRow">
                    ${thumbHtml}
                    <div class="contentText">
                      <div style="font-weight:700;">${title || "(no title)"}</div>
                      <div class="muted">author: ${author || "-"}</div>
                      ${mv ? `<div class="muted">mod_version: ${mv}</div>` : ""}
                      ${desc ? `<div style="margin-top:6px;">${desc}</div>` : `<div class="muted" style="margin-top:6px;">説明なし</div>`}
                      <div style="margin-top:8px;">${tagHtml}</div>
                    </div>
                  </div>
                </td>
                <td>
                  <div class="row" style="gap:8px;">
                    ${detailLink}
                    <button data-act="edit" data-id="${id}">編集</button>
                    <button class="primary" data-act="approve" data-id="${id}" ${(!canModerate || deleted) ? "disabled" : ""}>承認</button>
                    <button class="danger"  data-act="reject"  data-id="${id}" ${(!canModerate || deleted) ? "disabled" : ""}>却下</button>
                    <button class="danger"  data-act="delete"  data-id="${id}" ${deleted ? "disabled" : ""}>削除</button>
                    <button class="primary" data-act="restore" data-id="${id}" ${deleted ? "" : "disabled"}>復元</button>
                  </div>
                  <div class="muted" style="margin-top:8px;">
                    ※ 削除は論理削除。復元ボタンで戻せます。
                  </div>
                </td>
              </tr>
            `;
          }).join("")}
        </tbody>
      </table>
    `;

    // B: 描画/取得を後処理で実行
    enhanceThumbs().catch(()=>{});
  }

  async function load() {
    log(`loading...`);
    try {
      const data = await api(buildListQuery(), "GET");
      items = Array.isArray(data.items) ? data.items : [];
      log({ ok: true, loaded: items.length });
      render();
    } catch (e) {
      log({
        ok: false,
        hint: "401の場合：Cloudflare Access の保護範囲（mobcrafter.net/api/admin*）と、管理者Allowポリシーを確認してください。",
        error: e
      });
      $list.innerHTML = `<div class="muted">読み込み失敗（ログ参照）</div>`;
    }
  }

  function openEdit(item) {
    currentEdit = { id: item.id, item };
    $dlgInfo.textContent = `id=${item.id} / no=${item.submission_no ?? "-"} / unit_id=${item.unit_id ?? "-"}`;
    $editTitle.value = item.title || "";
    $editDesc.value  = item.description || "";
    $editTags.value  = parseTags(item.tags).join(" ");
    $editJson.value  = "";
    $dlgStatus.textContent = "-";
    $dlg.showModal();
  }

  async function doApprove(id) {
    const ok = confirm(`承認します。\nID: ${id}\nよろしいですか？`);
    if (!ok) return;
    log(`approve... ${id}`);
    await api(`submissions/${encodeURIComponent(id)}/approve`, "POST", {});
  }

  async function doReject(id) {
    const ok = confirm(`却下します。\nID: ${id}\nよろしいですか？`);
    if (!ok) return;
    log(`reject... ${id}`);
    await api(`submissions/${encodeURIComponent(id)}/reject`, "POST", {});
  }

  async function doDelete(id) {
    const ok = confirm(`削除（論理削除）します。\nID: ${id}\nよろしいですか？`);
    if (!ok) return;
    log(`delete... ${id}`);
    await api(`submissions/${encodeURIComponent(id)}`, "DELETE");
  }

  async function doRestore(id) {
    const ok = confirm(`復元します。\nID: ${id}\nよろしいですか？`);
    if (!ok) return;
    log(`restore... ${id}`);
    await api(`submissions/${encodeURIComponent(id)}/restore`, "POST", {});
  }

  $list.addEventListener("click", async (ev) => {
    const btn = ev.target.closest("button[data-act]");
    if (!btn) return;

    const act = btn.getAttribute("data-act");
    const id = btn.getAttribute("data-id");
    if (!act || !id) return;

    try {
      btn.disabled = true;

      if (act === "edit") {
        const it = items.find(x => String(x.id) === String(id));
        if (!it) throw { msg: "not_found_in_view" };
        openEdit(it);
        return;
      }
      if (act === "approve") await doApprove(id);
      if (act === "reject")  await doReject(id);
      if (act === "delete")  await doDelete(id);
      if (act === "restore") await doRestore(id);

      await load();
    } catch (e) {
      log({ ok: false, action: act, id, error: e });
    } finally {
      btn.disabled = false;
    }
  });

  $dlgClose.addEventListener("click", () => $dlg.close());

  $btnSaveMeta.addEventListener("click", async () => {
    if (!currentEdit) return;
    const id = currentEdit.id;
    const ok = confirm(`メタ情報を保存します。\nID: ${id}\nよろしいですか？`);
    if (!ok) return;

    $btnSaveMeta.disabled = true;
    $dlgStatus.textContent = "saving meta...";
    try {
      const body = {
        title: $editTitle.value,
        description: $editDesc.value,
        tags: $editTags.value
      };
      const r = await api(`submissions/${encodeURIComponent(id)}`, "PUT", body);
      $dlgStatus.textContent = "meta saved";
      log({ ok: true, action: "admin_meta_update", id, response: r });
      await load();
    } catch (e) {
      $dlgStatus.textContent = "meta failed";
      log({ ok: false, action: "admin_meta_update", id, error: e });
    } finally {
      $btnSaveMeta.disabled = false;
    }
  });

  $btnSaveJson.addEventListener("click", async () => {
    if (!currentEdit) return;
    const id = currentEdit.id;

    let obj = null;
    try {
      obj = JSON.parse($editJson.value || "");
    } catch {
      alert("JSONが壊れています（貼り付け内容を確認）");
      return;
    }
    const ok = confirm(`JSONを差し替えます。\nID: ${id}\nよろしいですか？`);
    if (!ok) return;

    $btnSaveJson.disabled = true;
    $dlgStatus.textContent = "saving json...";
    try {
      const r = await api(`submissions/${encodeURIComponent(id)}/json`, "PUT", { json: obj });
      $dlgStatus.textContent = "json saved";
      log({ ok: true, action: "admin_json_replace", id, response: r });
      await load();
    } catch (e) {
      $dlgStatus.textContent = "json failed";
      log({ ok: false, action: "admin_json_replace", id, error: e });
    } finally {
      $btnSaveJson.disabled = false;
    }
  });

  $reload.addEventListener("click", load);
  $status.addEventListener("change", load);

  let t = null;
  $q.addEventListener("input", () => {
    clearTimeout(t);
    t = setTimeout(load, 300);
  });
  $includeDeleted.addEventListener("change", load);

  (async () => {
    const ok = await warmupAccessSession();
    if (ok) await load();
  })();

})();
</script>

</body>
</html>
