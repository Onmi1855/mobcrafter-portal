<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MobCrafter - Unit Submit</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, sans-serif; margin: 24px; }
    .card { max-width: 720px; border: 1px solid #ddd; border-radius: 12px; padding: 16px; }
    label { display:block; margin-top: 12px; font-weight: 600; }
    input[type="text"], textarea { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 8px; }
    textarea { min-height: 84px; }
    .row { display:flex; gap: 12px; }
    .row > div { flex: 1; }
    button { margin-top: 14px; padding: 10px 14px; border: 0; border-radius: 10px; cursor:pointer; }
    button.primary { background:#111; color:#fff; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    pre { white-space: pre-wrap; word-break: break-word; background:#f6f6f6; padding: 12px; border-radius: 10px; }
    .hint { color:#555; font-size: 13px; margin-top: 8px; }
  </style>
</head>
<body>
  <div class="card">
    <h1>ユニット投稿</h1>
    <div class="hint">
      ※ 送信時に <code>https://api.mobcrafter.net/api/submit</code> にPOSTします。<br>
      ※ Cloudflare Accessで保護されている場合、ログインしていないと送信できません。
    </div>

    <label>JSONファイル</label>
    <input id="file" type="file" accept=".json,application/json" />

    <label>タイトル</label>
    <input id="title" type="text" placeholder="例: Sephiroth Unit v1" />

    <label>説明</label>
    <textarea id="description" placeholder="説明（任意）"></textarea>

    <div class="row">
      <div>
        <label>タグ（カンマ区切り）</label>
        <input id="tags" type="text" placeholder="例: boss, ff7, sword" />
      </div>
      <div>
        <label>mod_version（任意）</label>
        <input id="modVersion" type="text" placeholder="例: 1.0.0" />
      </div>
    </div>

    <button id="btn" class="primary" disabled>送信</button>

    <label>プレビュー</label>
    <pre id="preview">{}</pre>

    <label>結果</label>
    <pre id="result">未送信</pre>
  </div>

<script>
(() => {
  const $file = document.getElementById("file");
  const $title = document.getElementById("title");
  const $desc  = document.getElementById("description");
  const $tags  = document.getElementById("tags");
  const $mv    = document.getElementById("modVersion");
  const $btn   = document.getElementById("btn");
  const $prev  = document.getElementById("preview");
  const $res   = document.getElementById("result");

  let parsedJson = null;
function analyzeBlocks(blocks) {
  let minX = Infinity, minY = Infinity, minZ = Infinity;
  let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

  for (const b of blocks) {
    minX = Math.min(minX, b.dx);
    minY = Math.min(minY, b.dy);
    minZ = Math.min(minZ, b.dz);
    maxX = Math.max(maxX, b.dx);
    maxY = Math.max(maxY, b.dy);
    maxZ = Math.max(maxZ, b.dz);
  }

  return {
    count: blocks.length,
    sizeX: maxX - minX + 1,
    sizeY: maxY - minY + 1,
    sizeZ: maxZ - minZ + 1,
    minX, minY, minZ
  };
}

function colorFromBlockId(id) {
  if (!id) return "#888";
  let hash = 0;
  for (let i = 0; i < id.length; i++) {
    hash = (hash * 31 + id.charCodeAt(i)) | 0;
  }
  const r = 100 + (hash & 0x7F);
  const g = 100 + ((hash >> 8) & 0x7F);
  const b = 100 + ((hash >> 16) & 0x7F);
  return `rgb(${r},${g},${b})`;
}

function drawBlocks(canvas, blocks, info) {
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // ★重い時に固まらないよう安全策（最大1万ブロックだけ描く）
  const MAX_DRAW = 10000;
  let drawList = blocks;
  if (blocks.length > MAX_DRAW) {
    const step = Math.ceil(blocks.length / MAX_DRAW);
    drawList = blocks.filter((_, i) => i % step === 0);
  }

  // 画面に収まるスケールを計算（形状確認用）
  const scale = Math.max(
    1,
    Math.min(
      canvas.width / (info.sizeX + info.sizeZ + 2),
      canvas.height / (info.sizeY + info.sizeX + 2)
    ) * 20
  );

  const ox = canvas.width / 2;
  const oy = canvas.height * 0.75;

  function iso(x, y, z) {
    return {
      x: ox + (x - z) * scale,
      y: oy - (x + z) * scale * 0.5 - y * scale
    };
  }

  // 奥→手前で描く
  const sorted = [...drawList].sort((a, b) =>
    (a.dx + a.dz + a.dy) - (b.dx + b.dz + b.dy)
  );

  for (const b of sorted) {
    const p = iso(
      b.dx - info.minX,
      b.dy - info.minY,
      b.dz - info.minZ
    );

    ctx.fillStyle = colorFromBlockId(b.blockId);
    ctx.fillRect(p.x - scale / 2, p.y - scale / 2, scale, scale);
  }
}

  function validateMobCrafterJson(obj) {
    if (!obj || typeof obj !== "object") return "JSONがオブジェクトではありません";
    if (!Array.isArray(obj.blocks)) return "blocks 配列がありません";

    if (obj.blocks.length === 0) return "blocks が空です";
    if (obj.blocks.length > 200000) return "blocks が多すぎます（200k超）";

    for (let i = 0; i < Math.min(obj.blocks.length, 1000); i++) {
      const b = obj.blocks[i];
      if (typeof b.dx !== "number" || typeof b.dy !== "number" || typeof b.dz !== "number") {
        return `blocks[${i}] に dx/dy/dz がありません`;
      }
      if (typeof b.blockId !== "string") {
        return `blocks[${i}] に blockId がありません`;
      }
    }
    return null;
  }

  function setResult(objOrText) {
    $res.textContent = typeof objOrText === "string"
      ? objOrText
      : JSON.stringify(objOrText, null, 2);
  }

  function setPreview(objOrText) {
    $prev.textContent = typeof objOrText === "string"
      ? objOrText
      : JSON.stringify(objOrText, null, 2);
  }

  function updateButtonState() {
    const ok = !!parsedJson && ($title.value || "").trim().length > 0;
    $btn.disabled = !ok;
  }

  $file.addEventListener("change", async () => {
    parsedJson = null;
    setResult("未送信");
    const f = $file.files && $file.files[0];
    if (!f) { setPreview("{}"); updateButtonState(); return; }

    try {
      const text = await f.text();
      const obj = JSON.parse(text);
      parsedJson = obj;

      // タイトルが空ならファイル名から入れる
      if (!(($title.value || "").trim())) {
        $title.value = (f.name || "unit.json").replace(/\.json$/i, "");
      }

      const err = validateMobCrafterJson(parsedJson);
      if (err) {
        setPreview("MobCrafter用JSONとして不正: " + err);
      } else {
        // 軽いプレビュー
        const previewObj = {
          file: { name: f.name, size: f.size },
          blocks_count: Array.isArray(obj.blocks) ? obj.blocks.length : null,
          json_top: (obj && typeof obj === "object") ? Object.keys(obj).slice(0, 30) : null
        };
        setPreview(previewObj);
const canvas = document.getElementById("canvas");
const info = analyzeBlocks(parsedJson.blocks);
drawBlocks(canvas, parsedJson.blocks, info);

      }
    } catch (e) {
      setPreview("JSONとして読み込めませんでした: " + String(e && e.message ? e.message : e));
      parsedJson = null;
    }
    updateButtonState();
  });

  [$title, $desc, $tags, $mv].forEach(el => el.addEventListener("input", updateButtonState));

  $btn.addEventListener("click", async () => {
    updateButtonState();
    if ($btn.disabled) return;

    const err = validateMobCrafterJson(parsedJson);
    if (err) {
      setResult("送信できません: " + err);
      return;
    }

    const title = ($title.value || "").trim();
    const description = ($desc.value || "").trim();
    const tags = ($tags.value || "")
      .split(",")
      .map(s => s.trim())
      .filter(Boolean);
    const mod_version = ($mv.value || "").trim();

    const payload = { title, description, tags, mod_version, json: parsedJson };

    setResult("送信中...");

    try {
      const resp = await fetch("https://api.mobcrafter.net/api/submit", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        credentials: "include"
      });

      const text = await resp.text();
      let data = null;
      try { data = JSON.parse(text); } catch { data = { raw: text }; }

      setResult({ http: resp.status, ...data });
    } catch (e) {
      setResult("送信エラー: " + String(e && e.message ? e.message : e));
    }
  });
})();
</script>

</body>
</html>
